[{"title":"TypeScript-学习","url":"/2023/06/19/TypeScript-学习/","content":"\n\n## 浅谈 JavaScript\n\n\n\n### JavaScript 是一门优秀的编程语言吗？\n\n\n每个人可能观点并不完全一致，但是从很多角度来看，JavaScript 是一门非常优秀的编程语言；\n而且，可以说在很长一段时间内这个语言不会被代替，并且会在更多的领域被大家广泛使用；\n\n\n\n### 著名的 Atwood 定律：\n\nStack Overflow 的创立者之一的 Jeff Atwood 在 2007 年提出了著名的 Atwood 定律。\n\nany application that can be written in JavaScript, will eventually be written in JavaScript.\n\n任何可以使用 JavaScript 来实现的应用都最终都会使用 JavaScript 实现。\n\n其实我们已经看到了，这句话正在一步步被应验：\n\n\n   - Web 端的开发我们一直都是使用 JavaScript；\n   - 移动端开发可以借助于 ReactNative、Weex、Uniapp 等框架实现跨平台开发；\n   - 小程序端的开发也是离不开 JavaScript；\n   - 桌面端应用程序我们可以借助于 Electron 来开发；\n   - 服务器端开发可以借助于 Node 环境使用 JavaScript 来开发。\n\n\n\n### JavaScript 的痛点\n\n并且随着近几年前端领域的快速发展，让 JavaScript 迅速被普及和受广大开发者的喜爱，借助于 JavaScript 本身的 强大，也让使用 JavaScript 开发的人员越来越多。\n\n\n\n### 优秀的 JavaScript 没有缺点吗？\n\n其实上由于各种历史因素，JavaScript 语言本身存在很多的缺点；\n\n比如 ES5 以及之前的使用的 var 关键字关于作用域的问题；\n\n比如最初 JavaScript 设计的数组类型并不是连续的内存空间；\n\n比如直到今天 JavaScript 也没有加入类型检测这一机制；\n\n\n\n\n### JavaScript 正在慢慢变好\n\n不可否认的是，JavaScript 正在慢慢变得越来越好，无论是从底层设计还是应用层面。\n\nES6、7、8 等的推出，每次都会让这门语言更加现代、更加安全、更加方便。\n\n但是知道今天，JavaScript 在类型检测上依然是毫无进展（为什么类型检测如此重要，我后面会聊到）。\n\n\n\n### 类型带来的问题\n\n首先你需要知道，编程开发中我们有一个共识：**错误出现的越早越好**\n\n能在**写代码的时候**发现错误，就不要在**代码编译时**再发现（IDE 的优势就是在代码编写过程中帮助我们发现错 误）。\n\n能在**代码编译期间**发现错误，就不要在**代码运行期间**再发现（类型检测就可以很好的帮助我们做到这一点）。\n\n能在开发阶段发现错误，就不要在测试期间发现错误，能在测试期间发现错误，就不要在上线后发现错误。\n\n现在我们想探究的就是如何在 **代码编译期间** 发现代码的错误：\n\nJavaScript 可以做到吗？不可以，我们来看下面这段经常可能出现的代码问题。\n\n\n\n```js\nfunction getLength(str){\n  console.log(str.length)\n}\n\ngetLength('abc')\ngetLength()\n// 报错: Uncaught TypeError: Cannot read properties of undefined (reading 'length')\n```\n\n\n\n### 这是我们一个非常常见的错误：\n\n这个错误很大的原因就是因为 JavaScript 没有对我们传入的参数进行任何的限制，只能等到运行期间才发现这个 错误；\n并且当这个错误产生时，会影响后续代码的继续执行，也就是整个项目都因为一个小小的错误而深入崩溃；\n\n\n\n### 当然，你可能会想：我怎么可能犯这样低级的错误呢？\n\n当我们写像我们上面这样的简单的 demo 时，这样的错误很容易避免，并且当出现错误时，也很容易检查出来；\n\n但是当我们开发一个大型项目时呢？你能保证自己一定不会出现这样的问题吗？而且如果我们是调用别人的类\n\n库，又如何知道让我们传入的到底是什么样的参数呢？\n\n但是，如果我们可以给 JavaScript 加上很多限制，在开发中就可以很好的避免这样的问题了：\n\n比如我们的 getLength 函数中 str 是一个必传的类型，没有调用者没有传编译期间就会报错；\n\n比如我们要求它的必须是一个 String 类型，传入其他类型就直接报错；\n\n那么就可以知道很多的错误问题在编译期间就被发现，而不是等到运行时再去发现和修改；\n\n\n\n### 类型思维的缺失\n\n我们已经简单体会到没有类型检查带来的一些问题，JavaScript 因为从设计之初就没有考虑类型的约束问题，所以\n\n造成了前端开发人员关于**类型思维的缺失：**\n\n**前端开发人员**通常不关心变量或者参数是什么类型的，如果在必须确定类型时，我们往往需要使用各种判断验 证；\n\n从其他方向转到前端的人员，也会因为没有类型约束，而总是担心自己的代码不安全，不够健壮；\n\n所以我们经常会说 JavaScript**不适合开发大型项目**，因为当项目一旦庞大起来，这种宽松的类型约束会带来非常多 的安全隐患，多人员开发它们之间也没有**良好的类型契约。**\n\n比如当我们去实现一个核心类库时，如果没有类型约束，那么需要对别人传入的参数进行各种验证来保证我们 代码的健壮性；\n\n比如我们去调用别人的函数，对方没有对函数进行任何的注释，我们只能去看里面的逻辑来理解这个函数需要 传入什么参数，返回值是什么类型；\n\n\n\n### 为 JavaScript 添加类型约束的好处\n\n背景：JS 的类型系统存在“先天缺陷“，代码中绝大部分错误都是类型错误(Uncaught TypeError )。\n问题 ∶ 增加了找 Bug、改 Bug 的时间，严重影响开发效率。\n\n从编程语言的动静来区分\n\nTypeScript 属于静态类型的编程语言，JS 属于动态类型的编程语言\n\n静态类型︰编译期做类型检查；动态类型 ∶ 执行期做类型检查。\n\n代码编译和代码执行的顺序 ∶1 编译，2 执行。\n\n对于 JS 来说 ∶ 需要等到代码真正去执行的时候才能发现错误（晚）。\n\n对于 TS 来说 ∶ 在代码编译的时候（代码执行前）就可以发现错误（早）。\n\n并且，配合 VSCode 等开发工具，TS 可以提前到在编写代码的同时就发现代码中的错误，减少找 bug、改 bug 时间\n\n\n\n\n### Ts 相比 Js 的优势\n\n- 更早（写代码的同时）发现错误，减少找 Bug、改 Bug 时间，提升开发效率。\n- 程序中任何位置的代码都有代码提示，随时随地的安全感，增强了开发体验。\n- 强大的类型系统提升了代码的可维护性，使得重构代码更加容易。\n- 支持最新的 ECMAScript 语法，优先体验最新的语法，让你走在前端技术的最前沿。\n- TS 类型推断机制，不需要在代码中的每个地方都显示标注类型，让你在享受优势的同时，尽量降低了成本。\n- 除此之外，Vue 3 源码使用 TS 重写、Angular 默认支持 TS、React 与 TS 完美配合，TypeScript 已成为大中型前端项目的首选编程语言\n\n\n\n### 为了弥补 JavaScript 类型约束上的缺陷，增加类型约束，很多公司推出了自己的方案：\n\n2014 年，Facebook 推出了 flow 来对 JavaScript 进行类型检查；\n\n同年，Microsoft 微软也推出了 TypeScript1.0 版本；\n\n他们都致力于为 JavaScript 提供类型检查；\n\n而现在，**无疑 TypeScript 已经完全胜出：**\n\nVue2.x 的时候采用的就是 flow 来做类型检查；\n\nVue3.x 已经全线转向 TypeScript，98.3%使用 TypeScript 进行了重构；\n\n而 Angular 在很早期就使用 TypeScript 进行了项目重构并且需要使用 TypeScript 来进行开发；\n\n而甚至 Facebook 公司一些自己的产品也在使用 TypeScript；\n\n学习 TypeScript 不仅仅可以为我们的代码增加类型约束，而且可以培养我们前端程序员具备类型思维。\n\n\n\n## TypeScript 介绍\n\n![TypeScript 介绍](../images/tsjieshao.png)\n\n虽然我们已经知道 TypeScript 是干什么的了，也知道它解决了什么样的问题，但是我们还是需要全面的来认识一下 TypeScript 到底是什么？\n\n\n\n### 们来看一下 TypeScript 在 GitHub 和官方上对自己的定义：\n\nGitHub 说法：TypeScript is a superset of JavaScript that compiles to clean JavaScript output.\n\nTypeScript 官网：TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.\n\n翻译一下：TypeScript 是拥有类型的 JavaScript 超集，它可以编译成普通、干净、完整的 JavaScript 代码。\n\n怎么理解上面的话呢？\n\n我们可以将 TypeScript 理解成加强版的 JavaScript。\n\nJavaScript 所拥有的特性，TypeScript 全部都是支持的，并且它紧随 ECMAScript 的标准，所以 ES6、ES7、ES8 等新语法标准，它都是 支持的；\n\n并且在语言层面上，不仅仅增加了类型约束，而且包括一些语法的扩展，比如枚举类型（Enum）、元组类型（Tuple）等；\n\nTypeScript 在实现新特性的同时，总是保持和 ES 标准的同步甚至是领先；\n\n并且 TypeScript 最终会被编译成 JavaScript 代码，所以你并不需要担心它的兼容性问题，在编译时也不需要借助于 Babel 这样的工具；\n\n所以，我们可以把 TypeScript 理解成更加强大的 JavaScript，不仅让 JavaScript 更加安全，而且给它带来了诸多好用的好用特性；\n\n\n\n## TS 初体验\n\n### Ts 的编译环境\n\n在前面我们提到过，TypeScript 最终会被编译成 JavaScript 来运行，所以我们需要搭建对应的环境：\n\n我们需要在电脑上安装 TypeScript，这样就可以通过 TypeScript 的 Compiler 将其编译成 JavaScript；\n\n\n\n![TypeScript 2](../images/ts2.png)\n\n所以，我们需要全局安装\n\n\n#### 安装命令\n\n> npm install typescript -g\n\n\n\n#### 查看版本\n\n> tsc –version\n\n\n\n### TS 的运行环境\n\n如果我们每次为了查看 TypeScript 代码的运行效果，都通过经过两个步骤的话就太繁琐了：\n\n第一步：通过 tsc 编译 TypeScript 到 JavaScript 代码；\n\n第二步：在浏览器或者 Node 环境下运行 JavaScript 代码；\n\n是否可以简化这样的步骤呢？\n\n比如编写了 TypeScript 之后可以直接运行在浏览器上？\n\n比如编写了 TypeScript 之后，直接通过 node 的命令来执行？\n\n上面我提到的两种方式，可以通过两个解决方案来完成：\n\n\n\n#### 方式一：通过 webpack，配置本地的 TypeScript 编译环境和开启一个本地服务，可以直接运行在浏览器上；\n\n\n- npm init –y\n- npm i webpack webpack-cli –D\n- npm i ts-loader typescript –D\n\n\n```js\nconst path = require('path')\nmodule.exports = {\n  entry: './src/index.ts',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js'\n  },\n  resolve: {\n    extensions: ['.tsx','.ts', '.js']\n  },\n  module: {\n    rules: [\n      {\n        test: /.ts$/,\n        loader: 'ts-loader',\n        exclude: /node_modules/\n      }\n    ]\n  }\n  mode: 'development'\n}\n\n其它配置项参考webpack章节 ~\n```\n\n\n#### 方式二：通过 ts-node 库，为 TypeScript 的运行提供执行环境；\n\n安装 npm install -g ts-node\n\n另外 ts-node 需要依赖 tslib 和 @types/node 两个包：\n\nnpm install tslib @types/node -g\n\n现在，我们可以直接通过 ts-node 来运行 TypeScript 的代码：\n\nts-node index.ts\n\n注意：ts-node 7.0.0 以上就不自动识别 tsconfig.json 了，得加上 –files 才能识别\n\nts-node index.ts –files\n","tags":["TypeScript"],"categories":["前端"]},{"title":"uniapp-学习","url":"/2023/06/12/uniapp-学习/","content":"\n待更新~","tags":["uniApp"],"categories":["前端"]},{"title":"Vue3 学习","url":"/2023/06/09/Vue3-学习/","content":"\n## Vue3 简介\n\n\n![v3](../images/v3_1.png)\n\n\n* 2020 年 9 月 18 日，Vue.js 发布 3.0 版本，代号：One Piece(海贼王)\n\n* 耗时 2 年多、2600+次提交、30+个 RFC、600+次 PR、99 位贡献者\n\n* github 上的 tags 地址：https://github.com/vuejs/vue-next/releases/tag/v3.0.0\n\n\n\n\n## Vue3 带来了什么\n\n\n1. 性能的提升\n\n   * 打包大小减少41%\n   * 初次渲染快 55%, 更新渲染快 133%\n   * 内存减少 54%\n\n\n2. 源码的升级\n\n   * 使用 Proxy 代替 defineProperty 实现响应式\n   * 重写虚拟 DOM 的实现和 Tree-Shaking\n\n\n3. 拥抱 TypeScript\n\n   * Vue3 可以更好的支持 TypeScript\n\n\n4. 新的特性\n   \n   1. Composition API(组合 API)\n      \n       - setup 配置\n       - ref 与 reactive\n       - watch 与 watchEffect\n       - provide 与 inject\n       - ···\n\n\n    2. 新的内置组件\n       \n       - Fragment\n       - Teleport\n       - Suspense\n\n\n    3. 其他改变\n\n       - 新的生命周期钩子\n       - data 选项应始终被声明为一个函数\n       - 移除 keyCode 支持作为 v-on 的修饰符\n       - ···\n\n\n\n## 创建 vue3 项目\n\n```js\n  ## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上\n  vue --version\n  ## 安装或者升级你的@vue/cli\n  npm install -g @vue/cli\n  ## 创建\n  vue create vue3_study\n  ## 启动\n  cd vue3_study\n  npm run serve\n```\n\n\n## Options API 的弊端\n\n在 Vue2 中，我们编写组件的方式是 OptionsAPI：\n\nOptions API 的一大特点就是在对应的属性中编写对应的功能模块；\n\n比如 data 定义数据、methods 中定义方法、computed 中定义计算属性、watch 中监听属性改变，也包括生命 周期钩子;\n\n\n**但是这种代码有一个很大的弊端:**\n\n\n当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中；\n\n当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散；\n\n尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的（阅读组件的其他人）；\n\n\n\n**下面我们来看一个非常大的组件，其中的逻辑功能按照颜色进行了划分:**\n\n\n这种碎片化的代码使用理解和维护这个复杂的组件变得异常困难，并且隐藏了潜在的逻辑问题；\n\n并且当我们处理单个逻辑关注点时，需要不断的跳到相应的代码块中;\n\n\n\n|  OptionsAPI   | Composition API  |\n|  ----  | ----  |\n| ![OptionsAPI](../images/v3_2.png)  | ![Composition API](../images/v3_3.png) |\n\n\n\n如果我们能将同一个逻辑关注 点相关的代码收集在一起会更好。\n\n这就是**Composition API**想要做的事情，以及可以帮助我 们完成的事情。\n\n也有人把 Vue Composition API 简称为**VCA**。\n\n\n\n## 认识 Composition API\n\n那么既然知道 Composition API 想要帮助我们做什么事情，接下来看一下**到底是怎么做**呢？\n\n为了开始使用 Composition API，我们需要有一个可以实际使用它（编写代码）的地方；\n\n在 Vue 组件中，这个位置就是 setup 函数；\n\n**setup**其实就是组件的另外一个选项：\n\n只不过这个选项强大到我们可以用它来替代之前所编写的大部分其他选项；\n\n比如 methods、computed、watch、data、生命周期等等；\n\n**接下来我们一起学习这个函数的使用:**\n\n函数的参数\n\n函数的返回值\n\n\n\n### setup 函数的参数\n\n我们先来研究一个 setup 函数的参数，它主要有**两个参数:**\n\n第一个参数：props\n\n第二个参数：context\n\nprops 非常好理解，它其实就是**父组件传递过来的属性**会被放到 props 对象中，我们在**setup 中如果需要使用**,那么就可以直接通过 props 参数获取:\n\n对于定义 props 的类型，我们还是和之前的规则是一样的，在 props 选项中定义;\n\n并且在 template 中依然是可以正常去使用 props 中的属性，比如 message;\n\n如果我们在 setup 函数中想要使用 props，那么不可以通过 this 去获取（后面我会讲到为什么）;\n\n因为 props 有直接作为参数传递到 setup 函数中，所以我们可以直接通过参数来使用即可;\n\n另外一个参数是**context**,我们也称之为是一个**SetupContext**,它里面包含**三个属性:**\n\n   * **attrs：**所有的非 prop 的 attribute;\n   * **slots：**父组件传递过来的插槽(这个在以渲染函数返回时会有作用，后面会讲到);\n   * **emit：**当我们组件内部需要发出事件时会用到 emit（因为我们不能访问 this，所以不可以通过 this.$emit 发出事件）；\n\n\n\n### setup 函数的返回值\n\n   1. **若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）**\n   2. 若返回一个渲染函数：则可以自定义渲染内容。（了解）\n\n\n**注意点：**\n   1. 尽量不要与 Vue2.x 配置混用\n      - Vue2.x 配置（data、methos、computed…）中可以访问到 setup 中的属性、方法。\n      - 但在 setup 中不能访问到 Vue2.x 配置（data、methos、computed…）。\n      - 如果有重名, setup 优先。\n\n   2. setup 不能是一个 async 函数，因为返回值不再是 return 的对象, 而是 promise, 模板看不到 return 对象中的属性。（后期也可以返回一个 Promise 实例，但需要 Suspense 和异步组件的配合）\n\n\n\n### 另外注意：setup 不可以使用 this","tags":["Vue"],"categories":["前端"]},{"title":"Vue2 学习","url":"/2023/06/09/Vue2-学习/","content":"\n\n## Vue 简介\n\n\nVue 是一套用于构建用户界面的 渐进式框架 。\n\n与其它大型框架不同的是，Vue 采用自底向上增量开发的设计。\n\nVue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。\n\nVue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。\n\n最初它不过是个人项目，时至今日，已成为全世界三大前端框架之一，github 上拥有 19.8万 Star。 领先于 React 和 Angular，在国内更是首选。","tags":["Vue"],"categories":["前端"]},{"title":"小程序 学习","url":"/2023/06/09/小程序-学习/","content":"\n\n## 浅谈小程序\n\n  在 2016 年的「微信公开课 Pro」演讲中，微信事业群总裁张小龙这样描述了小程序的前景与未来：\n\n> \" 小程序是一种不需要下载安装即可使用的应用，它实现了应用 “触手可及” 的梦想，用户扫一扫或者搜一下即可打开应用。也体现了 “用完即走” 的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无须安装卸载 \"。\n\n\n  小程序刚发布的时候要求压缩包的体积不能大于 1M，否则无法通过，在 2017 年 4 月做 了改进，由原来的 1M 提升到 2M；\n\n  2017 年 1 月 9 日 0 点，万众瞩目的微信第一批小程序正式低调上线。\n\n  而在 2020年的「WWDC 苹果全球开发者大会」中，轻应用则被作为 iOS 14 的主要功能进行强调与推介：\n\n\n\n  ![你好](../images/wx1.png)\n\n\n> App Clip 就是一种无需用户在 iPhone 或 iPad 上安装完整的应用程序，就可以访问使用该应用程序的部分功能的轻量级应用，它们专注于处理简单快速的任务。\n\n\n\n不论是张小龙对「微信小程序」略带文艺的描述，还是在 WWDC 上对于「轻应用」在 iOS 生态中的地位描述，我们都能大抵能理解小程序诞生的初衷。而如果我们把时间从这两场发布会的转至今日，却会发现小程序早已不再局限于「用完即走」与「快速打开」，各式各样的小程序已呈现百花齐放的状态，不论是工具小程序，内容小程序，交易小程序，直播小程序，各种类型应有尽有。\n\n不妨让我尝试用自己的工作日常举例，早上出门上班，我会打开「天府健康通」扫描地铁场所码，并把健康码给地铁安检查看，临近中午 11 点 30 分，我会用「美团」或「饿了么」为自己订一份工作餐，吃完午饭后我会打开「动物餐厅」看看小猫咪又赚了多少小鱼干，下午会议时使用「腾讯文档」查看会议纪要，快下班的时候用「叮咚买菜」购置晚饭所需的食材，晚上回家做饭时，用「懒饭 App」看看想吃的番茄肥牛饭怎么做。\n\n\n\n![你好](../images/wx2.png)\n\n\n\n时至今日，当我们说到小程序时，也不仅仅在特指微信小程序，各式各样的平台都纷纷推出了自己专属的小程序平台，不论支付宝、字节跳动、美团还是百度等其他互联网大厂，都纷纷推出了自己专属的小程序平台，且都基于自己的生态业务，为小程序提供流量进行支持，希望用户与开发者能够选择自有平台中的小程序进行开发。\n\n随着小程序业务的愈演愈烈，越来越多的流量都被引入了互联网巨头的小程序战场中，但在这个过程中，对于战场中「封闭，不透明」的吐槽与争议也逐渐出现，无数企业都希望自己的应用中也能具备运行小程序的能力，希望能够借此抗争小程序被引入寡头所控制的战场，但「知易行难」，快速完成对小程序的底层与容器的研发，所需要花费的精力与时间并不是短时间就能够完成的。\n\n事实上，小程序可以被理解为是「移动应用 App」的一个细分子集，如果按照「平等透明」的设想，小程序不应该仅仅存在于微信之中，那些我们并不经常使用的应用都可以通过小程序进行重新优化，我们可以通过各式各样的专门应用打开相关的小程序，从而对那些「太重的应用」进行减负操作。\n\n当然了，小程序还会有这样一些特性需要我们注意：\n\n\n\n* 小程序不具备「被关注」的能力，获取流量留存用户的操作需要由独立应用或其他渠道完成;\n\n* 小程序不具备「推送消息与群发消息」的能力，对用户的信息触达与消息传递的操作需要由其他渠道完成;\n\n* 小程序不具备「跨 App 分享 」的能力，因此对于小程序的分享与打开路径，需要在设计产品时提前思考，而不是把鸡蛋放在一个篮子里;\n\n\n\n\n\n### 什么样的应用适合使用小程序开发\n\n\n虽然小程序市场时至今日依然是一片蓝海，但我想也不是所有应用「都可以，都应该」使用小程序开发的。\n\n基于我们的经验与积累来说，符合「逻辑简单，使用低频，对性能要求不极致」的应用场景，更加适合使用小程序进行研发。\n\n\n\n\n#### 逻辑简单：\n\n是指应用的操作逻辑并不十分复杂，各类生活服务（如打车，订餐，查地图与导航等等）都需要给用户提供简单清晰的操作逻辑，而这一类也天然的符合起初小程序「用完即走」的定义，因此十分符合使用小程序研发。一些逻辑复杂的应用场景想要通过小程序进行适配，就可能会面临更多的设计与研发困难，同时在性能和体验也可能会面对更多需要解决的问题。\n\n\n\n#### 使用低频：\n\n是指小程序的使用频率不应该太高，比如社交类的钉钉或飞书，金融类的掌上生活或浦大喜奔，媒体类的网易云音乐或斗鱼都不太适合使用小程序进行重新设计。对于用户使用的频率较高的应用来说，直接打开应用进行体验的步骤肯定最快的，此外由于某些行业的特殊性质（比如具备交易，支付等能力）要求，对于安全性与保密性的首选风险判断原则，也不宜使用常见的小程序进行设计。\n\n\n\n#### 对性能要求不极致：\n\n是指由于小程序始终存在于某个独立应用（也被称为宿主应用）中，考虑到目前的性能与研发所限制，暂时不太适合开发对于这两者有更高要求的移动应用。比如把原神，王者荣耀这样的游戏应用通过小程序进行重新设计，在目前来说肯定是不现实的。\n\n当然，随着相关研发实力的增强与产业生态的逐渐补充，也有越来越多的「不可能」变为了「可能」，比如华西证券的「华彩人生」，浦发银行的「浦大喜奔」，某省的移动警务平台等客户都选择使用小程序容器方案进行落地实现\n\n\n\n\n### 小程序与 H5，原生应用有何区别？\n\n很多朋友在了解小程序技术的时候，都会有这样的疑惑“到底与 H5，原生应用”这些技术相比，小程序具有哪些优势与劣势呢？\n\n\n\n\n#### H5 移动应用\n\n我们常说的 H5 其实也通常可以被视为一种 Web App，相比于我们在桌面端浏览器中打开的网页，主要是增加了一些响应式的设计与交互优化，从而使得这些网页更适合在移动端的浏览器中显示运行。既然是网页应用，那依然是基于 JavaScript，CSS 和 HTML 进行实现的，由于是基于各类前端技术栈进行实现，最大的好处就是快速、简单、方便，且有各种技术资料可以参考。\n\n同样，H5 的缺点与优点也是并存的，比如由于技术已经很成熟了，对于前端经验欠缺的新人来说，面对各式各样的框架，模块、任务管理工具，UI 库可能会出现无从下手的问题；此外相比于原生应用，对于系统权限的获取（比如数据缓存能力，网络通信状态等）都显得比较鸡肋，当低性能的设备加载包含复杂逻辑的页面时，会出现明显的卡顿与延迟问题。\n\n\n\n#### 原生应用\n\n原生应用也被叫做 Native App，相比于 H5 应用通过前端三大件进行实现不同，原生应用主要会采用 iOS 与 Android 的专有语言 Object-C（或 Swift），Java（或 Kotlin）进行实现，大多我们所常见的国民应用，比如微信，支付宝等都属于这种原生应用。\n\n既然被叫做「原生应用」，就像操作系统的亲儿子一样，天然在性能与体验上具备优秀的潜质，也有组件库丰富，接口支持完善等各种优势特点。但原生应用最大的缺陷就是不能跨平台研发，以目前的主流市场为例，必须要支持 iOS 与 Android 两个主流平台。\n\n\n\n\n#### 混合应用\n\n混合应用一般被称为 Hybrid App。简单来说，混合应用就是将原生功能封装成对应的 JS 接口，在前端使用 H5 来开发对应的 App （即 H5 作为内容+原生应用作为壳） ，看上去虽然是一个移动原生应用整体，但实际的页面还是网页，一套代码可以生成 iOS 与 Android 两种安装包，开发成本较低。\n\n我们常见的淘宝，京东等应用由于更新与优化节奏都十分快速，为了更好的响应「贴近用户」的目标，应用中有的功能通过原生 Native 实现，有的功能则通过 H5 页面进行实现，这种应用就属于我们所说的混合应用。\n\n\n\n#### 小程序\n\n严格意义上来说，小程序并不属于以上 3 种应用的任何一种。小程序主要通过 JavaScript 与 CSS 这种常见的前端技术进行开发，但又没有完全使用 HTML 进行实现，在不同的操作系统中，JavaScript 代码分别运行在 iOS 的 JavaScriptCore 与 Android 的 X5 JSCore 中，各家小程序平台或多或少都有一部分自研的核心，因此渲染视图层的组件也有所不同。\n\n\n\n![你好](../images/wx3.png)\n\n\n相比「 H5 移动应用」与「 移动原生应用」，小程序具备如下优势：\n\n\n  - 具备跨平台的能力，一套代码可以在 iOS 与 Android 两个平台中运行；\n  - 远超过 H5 的体验（支持本地缓存，Webview，有丰富的组件与支持库）；\n  - 能获取更多系统权限，完成更加丰富的产品设计；\n  - 可以避免 DOM 泄露（不使用常用的 window 对象与 document 对象）；\n  - 开发简单，上手成本低（比如 FinClip 提供了 FIDE 与开发文档）；\n\n\n\n\n\n#### 常见的小程序开发框架有哪些\n\n以主要的小程序开发框架举例，腾讯云社区的「极乐君」将不同平台下小程序支持的力度整理在一张表中：\n\n\n![你好](../images/wx4.png)\n\n\n\n## 小程序开发环境\n\n\n1、[微信文档](https://developers.weixin.qq.com/miniprogram/dev/framework/)\n\n2、[微信开发工具下载](https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html)\n\n3、[注册小程序账号](https://mp.weixin.qq.com/)\n\n\n\n![账号分类](../images/wx5.png)\n\n\n![小程序注册](../images/wx6.png)\n\n\n\n## 小程序特点\n\n\n1. 没有 DOM\n\n2. 组件化开发： 具备特定功能效果的代码集合\n\n3. 体积小，单个压缩包体积不能大于 2M，否则无法上线\n\n4. 小程序的四个重要的文件\n\n   - .js —> js 逻辑 —> js\n   - .wxml —> view 结构—–> html\n   - .wxss —> view 样式 —–> css\n   - .json —-> view 配置—– > json 文件\n\n\n\n5. 小程序适配方案: rpx (responsive pixel 响应式像素单位)\n\n- 小程序适配单位： rpx\n- 规定任何屏幕下宽度为 750rpx\n- 小程序会根据屏幕的宽度不同自动计算 rpx 值的大小\n- Iphone6 下： 1rpx = 1 物理像素 = 0.5px\n\n\n\n![尺寸单位](../images/wx7.png)\n\n\n\n\n## 小程序配置\n\n\n### 全局配置\n\n> 作用： 用于为整个应用进行选项设置\n\n\n![全局配置](../images/wx8.png)\n\n\n\n### 页面配置\n\n\n    配图参上\n\n    作用：用于为指定的页面进行配置\n\n    注：页面配置的优先级高于全局配置\n\n\n\n### sitemap 配置\n\n\n   配图参上\n\n   作用：配置其小程序页面是否允许微信索引\n\n\n\n\n## 小程序基础\n\n\n### 框架接口\n\n![框架接口](../images/wx9.png)\n\n\n\n#### App\n\n\n   1. 全局 app.js 中执行 App()\n   2. 生成当前应用的实例对象\n   3. getApp()获取全局应用实例\n\n\n\n\n#### Page\n\n\n   1. 页面.js 中执行 Page()\n   2. 生成当前页面的实例\n   3. 通过 getCurrentPages() 获取页面实例\n\n\n\n\n### WXML 语法\n\n\n![WXML 语法](../images/wx10.png)\n\n\n> 具体看官方文档 ~\n\n\n\n#### ToDoList\n\n- todolist.wxml\n\n\n\n```js\n<view class=\"container\">\n    <view class=\"header\">\n        <input type=\"text\" class=\"header-input\"\n        bindinput=\"inputHandler\"\n        value='{{text.title?text.title:\"\"}}'/>\n        <button type=\"primary\" size=\"mini\"\n        bindtap=\"add\">添加</button>\n    </view>\n\n    <view class=\"show\" wx:if=\"{{todoList.length > 0}}\">\n        <view wx:for=\"{{todoList}}\" wx:key=\"id\">{{item.id + 1}}. {{item.title}}\n        <button type=\"warn\"\n        size=\"mini\"\n        bindtap=\"del\"\n        data-index=\"{{index}}\"\n        >删除</button>\n        </view>\n    </view>\n\n    <view wx:else>暂无待办事项</view>\n</view>\n```\n\n\n\n- todolist.js\n\n\n```js\nPage({\n  /**\n   * 页面的初始数据\n   */\n  data: {\n    todoList: [\n      { id: 0, title: \"吃饭\" },\n      { id: 1, title: \"睡觉\" },\n      { id: 2, title: \"打豆豆\" },\n    ],\n    // 保存用户输入的数据\n    text: \"\",\n  },\n  // 用户输入数据后会触发的回调\n  inputHandler(e) {\n    // 保存用户输入的数据\n    this.setData({\n      text: {\n        id: this.data.todoList.length,\n        title: e.detail.value,\n      },\n    });\n  },\n  // 添加\n  add() {\n    // 修改数据并且清空输入框\n    this.setData({\n      todoList: [...this.data.todoList, this.data.text],\n      text: \"\",\n    });\n  },\n  // 删除\n  del(e) {\n    // 获取传过来的索引\n    // console.log(e.target.dataset.index)\n    var index = e.target.dataset.index;\n    // 删除数据\n    this.data.todoList.splice(index, 1);\n    // 只要修改了数据 一定要重新setData\n    this.setData({\n      todoList: this.data.todoList,\n    });\n  },\n});\n```\n\n- todolist.wxss\n\n```js\n.container {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n}\n.header {\n    display: flex;\n    margin-top: 20rpx;\n}\n.header-input {\n    height: 64rpx;\n    line-height: 64rpx;\n    border: 1px solid #000;\n    text-align: center;\n    margin-right: 20rpx;\n}\n.show {\n    margin-top: 20rpx;\n}\n```\n\n\n\n#### Tab\n\n- tab.wxml\n\n\n```js\n<view class=\"container\">\n  <view\n    class=\"tab {{index == current ? 'active' : ''}}\"\n    bindtap=\"changeCurrent\"\n    data-index=\"{{index}}\"\n    wx:for=\"{{tabList}}\"\n    wx:key=\"*this\"\n  >\n    <text>{{ item }}</text>\n  </view>\n</view>\n```\n\n\n- tab.js\n\n\n```js\nPage({\n  /**\n   * 页面的初始数据\n   */\n  data: {\n    tabList: [\"首页\", \"购物车\", \"我的\"],\n    current: 0,\n  },\n  changeCurrent(e) {\n    // 在事件处理函数中，通过 event.target.dataset.参数名 即可获取到具体参数的值\n    console.log(e.currentTarget.dataset.index);\n    this.setData({\n      current: e.target.dataset.index,\n    });\n  },\n});\n```\n\n\n- tab.wxss\n\n```js\n.container {\n    display: flex;\n    justify-content: space-around;\n}\n.tab {\n    text-align: center;\n    width: 200rpx;\n    border: 1px solid black;\n}\n.active {\n    border-bottom: 2px solid red;\n}\n```\n\n\n\n#### target 和 currentTarget 的区别？\n\n> target 是触发该事件的源头组件，而 currentTarget 则是当前事件所绑定的组件\n\n\n![target 和 currentTarget 的区别](../images/wx11.png)","tags":["微信小程序"],"categories":["前端"]},{"title":"NodeJs 学习","url":"/2023/06/08/NodeJs-学习/","content":"\n\n\n\n## node.js 介绍\n\n### node.js 是什么？\n\n  1. node.js 是一个开发平台，就像Java开发平台、.Net开发平台、PHP开发平台、Apple开发平台一样。\n   - 何为开发平台？有对应的编程语言、有语言运行时、有能实现特定功能的API(SDK：Software Development Kit)\n\n  2. nodejs平台使用的编程语言是 JavaScript 语言。\n   - 不支持 window、document、bom 对象。\n\n  3. node.js平台是基于 Chrome V8 JavaScript 引擎构建。\n\n  4. 基于 node.js 可以开发控制台程序(命令行程序、CLI程序)、桌面应用程序(GUI)(借助 node-webkit、electron 等框架实现)、Web 应用程序(网站)。\n\n  > PHP开发技术栈: LAMP - Linux Apache MySQL PHP\n  > node.js 全栈开发技术栈: MEAN - MongoDB Express Angular Node.js\n\n\n### node.js 有哪些特点？\n\n  1. 事件驱动(当事件被触发时，执行传递过去的回调函数)\n  2. 非阻塞 I/O 模型(当执行I/O操作时，不会阻塞线程)\n  3. 单线程\n  4. 拥有世界最大的开源库生态系统 —— npm。\n\n\n### node.js 网站\n\n  1. [node.js官方网站](https://nodejs.org/en)\n  2. [node.js中文网](https://nodejs.cn/)\n  3. [node.js中文社区](https://cnodejs.org/)\n\n\n### 学习目标\n\n  1. 了解服务器开发过程\n  2. 会使用 node.js 开发基本的 http 服务程序(Web应用程序)\n\n\n### Node.js可以用来做什么？\n\n  * 具有复杂逻辑的动态网站\n  * WebSocket服务器\n  * 命令行工具\n  * 带有图形界面的本地应用程序\n  * ···\n\n\n\n## 终端基本使用\n\n### 打开应用\n\n  * notepad 打开记事本\n  * mspaint 打开画图\n  * calc 打开计算机\n  * write 打开写字板\n  * sysdm.cpl 打开环境变量设置窗口\n\n\n### 常用命令\n\n  * md 创建目录\n  * rmdir(rd) 删除目录，目录内没有文档\n  * echo on a.txt 创建空文件\n  * del 删除文件\n  * rm 文件名 删除文件\n\n\n\n### Node.js开发环境准备\n\n1. 普通安装方式[官方网站](https://nodejs.org/zh-cn)\n\n2. 多版本安装方式\n\n  * 卸载已有的Node.js\n  * 下载nvm\n  * 在C盘创建目录dev\n  * 在dev目中中创建两个子目录nvm和nodejs\n  * 并且把nvm包解压进去nvm目录中\n  * 在install.cmd文件上面右键选择【以管理员身份运行】\n  * 打开的cmd窗口直接回车会生成一个settings.txt文件，修改文件中配置信息\n  * 配置nvm和Node.js环境变量\n\n   > NVM_HOME:C:\\dev\\nvm\n   > NVM_SYMLINK:C:\\dev\\nodejs\n\n  * 把配置好的两个环境变量加到Path中\n\n\n\n### nvm常用的命令\n  - nvm list 查看当前安装的Node.js所有版本\n  - nvm install 版本号 安装指定版本的Node.js\n  - nvm uninstall 版本号 卸载指定版本的Node.js\n  - nvm use 版本号 选择指定版本的Node.js\n\n\n\n### Node.js之HelloWorld\n\n  - 命令行方式REPL\n  - 运行文件方式\n  - 全局对象概览\n\n\n\n### Node.js 开发 Web 应用程序 和 PHP、Java、ASP.Net等传统模式开发Web应用程序区别\n\n1. #### 传统模式\n\n  * 有 Web 容器\n\n![有Web容器开发模型](../images/Web.png)\n\n\n2. #### Node.js 开发 Web 应用程序\n\n  * 没有 Web 容器\n\n![没有Web容器开发模型](../images/nodejs10.png)\n\n\n\n\n## 在 node.js 上编写程序\n\n### REPL 介绍\n\n1. REPL 全称: Read-Eval-Print-Loop(交互式解释器)\n\n - R 读取 - 读取用户输入，解析输入了 Javascript 数据结构并存储在内存中。\n - E 执行 - 执行输入的数据结构\n - P 打印 - 输出结果\n - L 循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。\n\n2. 在 REPL 中编写程序 (类似于浏览器开发人员工具中的控制台功能)\n\n  - 直接在控制台输入 node 命令进入 REPL 环境\n\n\n3. 按两次 Control + C 退出 REPL 界面 或者 输入 .exit 退出 REPL 界面\n\n  - 按住 control 键不要放开, 然后按两下 c 键\n\n\n\n### 创建 JavaScript 文件编写程序\n\n#### JavaScript 文件名命名规则\n\n  * 不要用中文\n  * 不要包含空格\n  * 不要出现 node 关键字，比如：node.js\n  * 建议以 ‘-’ 分割单词\n\n\n### 案例 1：编写一个简单的函数, 实现数字相加\n\n```js\nvar n = 10;\nvar m = 100;\n\nfunction add(x, y) {\n  return x + y;\n}\n\nvar result = add(m, n);\n\nconsole.log(\"计算结果是：\" + result);\n```\n\n\n\n### 案例 2：文件读写案例","tags":["NodeJs"],"categories":["后端"]},{"title":"React 学习","url":"/2023/06/08/React-学习/","content":"\n\n## React 简介\n\n\n\n### 一、什么是 React ？(What is React？)\n\n  > React是一个声明式的，高效的，并且灵活的用于构建用户界面的 JavaScript 库。它允许您使用”components(组件)“（小巧而独立的代码片段）组合出各种复杂的UI。\n\n\n### 二、React谁开发的？\n\n  > 由Facebook开发且开源，近十年“陈酿”，阿里等大厂开始使用\n\n\n### 三、为什么要学？\n\n\n  #### &nbsp;(一)原生js痛点\n\n  1. 原生JavaScript操作DOM繁琐、效率低（DOM-API操作UI）\n\n    ```js\n    document.getElementById('app')\n    document.querySelector('#app')\n    document.getElementsByTagName('span')\n    ```\n\n  2. 使用JavaScript直接操作DOM，浏览器会进行大量的重绘重排\n\n  3. 原生JavaScript没有组件化（模块化）编码方案，代码复用率低\n\n\n  #### (二)React特点\n\n  1. 采用组件化模式，声明式编码，提高开发效率和组件复用率\n\n  2. 在React Native中可以用React语法进行移动端开发\n\n  3. 使用虚拟DOM和优秀的Diffing算法，尽量减少与真实DOM的交互，提高性能\n\n\n### 四、React依赖介绍？\n","tags":["React"],"categories":["前端"]},{"title":"Hello World","url":"/2023/05/24/hello-world/","content":"\n## “永远不要失去浪漫的能力”。\n\n  ​这个浪漫不单单是指恋爱，更多的是：\n\n  对于世界的好奇和探索，阅读和书写，天真的想法和骨子里的善良，\n\n  对于生活必要的仪式感，以及拥有对恶意和黑暗的事物抱有愤怒和反抗的能力 ~\n\n  和这个世界交手多年，渐渐失去了一些耐心，身体劳累，精神也麻木，对什么都提不起兴趣，\n\n  把漫长的生命活成同一天，但这样不行，早晚有一天是要发疯的 ~\n\n  还是要一些坚守和浪漫，要一些别人看来非必要的事物来拯救自己 ~\n\n  要一些海风，夏天的雨，要低吟的音乐和沉浸的电影，要在心里点燃一盏烛火 ~\n\n  停止被这个世界融化，花一些时间在这些事物上，\n\n  凝成自己坚固的核，保护好自己闪闪发光的部分，哪怕只是徒劳 ~\n\n  觉得难过的时候，记得抬头看看月亮 ~"}]