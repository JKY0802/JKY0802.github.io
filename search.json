[{"title":"Three.js-学习","url":"/2023/08/29/ThreeJs-学习/","content":"\n## 简介\n- Three.js 是一款运行在浏览器中的 3D 引擎，你可以用它创建各种三维场景，包括了摄影机、光影、材质等各种对象。你可 以在它的主页上看到许多精采的演示。不过，这款引擎目前还处在比较不成熟的开发阶段，其不够丰富的 API 以及匮乏的文档增加了初学者的学习难度（尤其是文档的匮乏）"},{"title":"缘析-瑾瑜","url":"/2023/08/27/RH-工作随笔/","content":"\n\n## BUG记录\n\n\n\n## 新知识\n\n### H5调用安卓和IOS相机权限\n\n```js\n  var u = navigator.userAgent;\n  var isAndroid = u.indexOf(\"Android\") > -1 || u.indexOf(\"Adr\") > -1; //android终端\n  var isiOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端\n\n  if (isAndroid) {\n  this.isShow = true;\n  console.log(window.plus.android, \"安卓\");\n  window.plus.android.requestPermissions(\n    [\"android.permission.CAMERA\"],\n    function (e) {\n      if (e.deniedAlways.length > 0) {\n        //权限被永久拒绝\n        // 弹出提示框解释为何需要权限，引导用户打开设置页面开启\n        console.log(\"权限被永久拒绝\" + e.deniedAlways.toString());\n      }\n      if (e.deniedPresent.length > 0) {\n        //权限被临时拒绝\n        // 弹出提示框解释为何需要权限，可再次调用plus.android.requestPermissions申请权限\n        console.log(\"权限被临时拒绝\" + e.deniedPresent.toString());\n      }\n      if (e.granted.length > 0) {\n        //权限被允许\n        console.log(\"权限被允许\" + e.granted.toString());\n        that.openPay();\n      }\n    },\n    function (e) {\n      console.log(\"Request Permissions error:\" + JSON.stringify(e));\n    }\n  );\n} else {\n  this.isShow = false;\n  navigator.mediaDevices\n    .getUserMedia({\n      video: {\n        facingMode: \"environment\",\n        width: this.height,\n        height: this.width,\n      },\n    })\n    .then((stream) => {\n      console.log(\"相机权限已授权\");\n      this.QrScannerInit();\n      this.scanQrCode();\n    })\n    .catch((err) => {\n      console.log(\"相机权限授权失败\", err);\n      if (err.name === \"NotAllowedError\") {\n        // 用户已禁止访问权限，引导用户更改权限设置\n        // 显示提示信息，引导用户手动更改权限设置\n        Dialog.alert({\n          title: \"提示\",\n          message: \"您的相机功能好像有问题哦~去“设置>隐私>相机”开启一下吧\",\n          theme: \"round-button\",\n        }).then(() => {\n          this.$router.push(\n            {\n              name: \"/sweep\",\n            },\n            () => {}\n          );\n        });\n      } else {\n        console.log(\"其他错误\");\n      }\n    });\n```\n\n\n\n\n### H5直接判断iOS相机权限\n```js\n  var AVCaptureDevice = window.plus.ios.import(\"AVCaptureDevice\");\n  var authStatus = AVCaptureDevice.authorizationStatusForMediaType(\"vide\");\n  console.log(\"authStatus:\" + authStatus);\n    if (authStatus == 3) {\n      console.log(\"相机权限已经开启\");\n    } else {\n      console.log(\"相机权限没有开启\");\n    }\n```\n\n\n\n\n### H5获取 Android MAC地址\n\n```js\n  // 导入Java类。Networklnterface类表示一个由名称和分配给此接口的IP地址列表组成的网络接口\n  const net = window.plus.android.importClass(\"java.net.NetworkInterface\");\n  // 搜索具有指定名称的网络接口\n  const wlan0 = net.getByName(\"wlan0\");\n  // 获得网卡的硬件地址\n  const macByte = wlan0.getHardwareAddress();\n  let macStr = \"\";\n  //转换MAC地址的思路来自网上\n  macByte.forEach((item) => {\n    // .toString(16)数字以十六进制值显示\n    let temp = \"\";\n    if (item < 0) temp = (256 + item).toString(16);\n    else temp = item.toString(16);\n    if (temp.length == 1) temp = `0${temp}`;\n    macStr += temp;\n  });\n  let MAC = macStr.toUpperCase();\n  for (let i = 2; i < MAC.length; i += 3)\n    MAC = MAC.slice(0, i) + \":\" + MAC.slice(i);\n  console.log(\"MAC: \" + MAC);\n  // this.macAdr = MAC;\n  this.getIPAddresses();\n  this.goToWallet();\n```\n\n\n\n\n### 随机生成MAC地址\n```js\nfunction generateMockMACAddress() {\n  const characters = \"0123456789ABCDEF\";\n  let macAddress = \"\";\n  for (let i = 0; i < 6; i++) {\n    for (let j = 0; j < 2; j++) {\n      macAddress += characters.charAt(\n        Math.floor(Math.random() * characters.length)\n      );\n    }\n    if (i !== 5) {\n      macAddress += \":\";\n    }\n  }\n  return macAddress;\n}\n\nlet clientMACId = localStorage.getItem(\"clientMACId\");\n\nif (!clientMACId) {\n  clientMACId = generateMockMACAddress();\n  localStorage.setItem(\"clientMACId\", clientMACId);\n}\nconsole.log(\"clientMACId:\", clientMACId);\n```\n\n\n\n### H5获取经纬度\n```js\ngetGps() {\n  if (navigator.geolocation) {\n    navigator.geolocation.getCurrentPosition(\n      function (position) {\n        var latitude = position.coords.latitude;\n        var longitude = position.coords.longitude;\n      },\n      function (error) {\n        console.log(\"Error occurred. Error code: \" + error.code);\n        alert(error);\n      }\n    );\n  } \n  else {\n    console.log(\"Geolocation is not supported by this browser.\");\n   }\n  },\n```\n\n\n\n### H5获取IP地址1.0\n\n```js\ngetIP(callback) {\n    const xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", \"https://api.ipify.org\", true);\n    xhr.onreadystatechange = function () {\n      if (xhr.readyState === 4 && xhr.status === 200) {\n        callback(xhr.responseText);\n      }\n    };\n    xhr.send();\n  }\n\n  this.getIP((ip) => {\n    console.log('Your IP',ip)\n  });\n```\n\n\n\n### H5获取IP地址2.0\n\n```js\ngetIp2() {\n  fetch(\"https://api.ipify.org?format=json\")\n    .then((response) => response.json())\n    .then((data) => {\n      const ip = data.ip;\n      sessionStorage.setItem(\"clientIp\", ip);\n      console.log(\"Your IP address is: \" + ip);\n      this.clientIp = ip;\n      console.log(this.clientIp, \"--------getIp2--------\");\n    })\n    .catch((error) => {\n      console.log(\"Error occurred: \" + error);\n    });\n  },\n```\n\n\n### 更多Android权限列表\n\n```js\n权限 名称 描述\nandroid.permission.ACCESS_CHECKIN_PROPERTIES 访问登记属性 读取或写入登记check-in数据库属性表的权限\nandroid.permission.ACCESS_COARSE_LOCATION 获取错略位置 通过WiFi或移动基站的方式获取用户错略的经纬度信息,定位精度大概误差在30~1500米\nandroid.permission.ACCESS_FINE_LOCATION 获取精确位置 通过GPS芯片接收卫星的定位信息,定位精度达10米以内\nandroid.permission.ACCESS_LOCATION_EXTRA_COMMANDS 访问定位额外命令 允许程序访问额外的定位提供者指令\nandroid.permission.ACCESS_MOCK_LOCATION 获取模拟定位信息 获取模拟定位信息,一般用于帮助开发者调试应用\nandroid.permission.ACCESS_NETWORK_STATE 获取网络状态 获取网络信息状态,如当前的网络连接是否有效\nandroid.permission.ACCESS_SURFACE_FLINGER 访问Surface Flinger Android平台上底层的图形显示支持,一般用于游戏或照相机预览界面和底层模式的屏幕截图\nandroid.permission.ACCESS_WIFI_STATE 获取WiFi状态 获取当前WiFi接入的状态以及WLAN热点的信息\nandroid.permission.ACCOUNT_MANAGER 账户管理 获取账户验证信息,主要为GMail账户信息,只有系统级进程才能访问的权限\nandroid.permission.AUTHENTICATE_ACCOUNTS 验证账户 允许一个程序通过账户验证方式访问账户管理ACCOUNT_MANAGER相关信息\nandroid.permission.BATTERY_STATS 电量统计 获取电池电量统计信息\nandroid.permission.BIND_APPWIDGET 绑定小插件 允许一个程序告诉appWidget服务需要访问小插件的数据库,只有非常少的应用才用到此权限\nandroid.permission.BIND_DEVICE_ADMIN 绑定设备管理 请求系统管理员接收者receiver,只有系统才能使用\nandroid.permission.BIND_INPUT_METHOD 绑定输入法 请求InputMethodService服务,只有系统才能使用\nandroid.permission.BIND_REMOTEVIEWS 绑定RemoteView 必须通过RemoteViewsService服务来请求,只有系统才能用\nandroid.permission.BIND_WALLPAPER 绑定壁纸 必须通过WallpaperService服务来请求,只有系统才能用\nandroid.permission.BLUETOOTH 使用蓝牙 允许程序连接配对过的蓝牙设备\nandroid.permission.BLUETOOTH_ADMIN 蓝牙管理 允许程序进行发现和配对新的蓝牙设备\nandroid.permission.BRICK 变成砖头 能够禁用手机,非常危险,顾名思义就是让手机变成砖头\nandroid.permission.BROADCAST_PACKAGE_REMOVED 应用删除时广播 当一个应用在删除时触发一个广播\nandroid.permission.BROADCAST_SMS 收到短信时广播 当收到短信时触发一个广播\nandroid.permission.BROADCAST_STICKY 连续广播 允许一个程序收到广播后快速收到下一个广播\nandroid.permission.BROADCAST_WAP_PUSH WAP PUSH广播 WAP PUSH服务收到后触发一个广播\nandroid.permission.CALL_PHONE 拨打电话 允许程序从非系统拨号器里输入电话号码\nandroid.permission.CALL_PRIVILEGED 通话权限 允许程序拨打电话,替换系统的拨号器界面\nandroid.permission.CAMERA 拍照权限 允许访问摄像头进行拍照\nandroid.permission.CHANGE_COMPONENT_ENABLED_STATE 改变组件状态 改变组件是否启用状态\nandroid.permission.CHANGE_CONFIGURATION 改变配置 允许当前应用改变配置,如定位\nandroid.permission.CHANGE_NETWORK_STATE 改变网络状态 改变网络状态如是否能联网\nandroid.permission.CHANGE_WIFI_MULTICAST_STATE 改变WiFi多播状态 改变WiFi多播状态\nandroid.permission.CHANGE_WIFI_STATE 改变WiFi状态 改变WiFi状态\nandroid.permission.CLEAR_APP_CACHE 清除应用缓存 清除应用缓存\nandroid.permission.CLEAR_APP_USER_DATA 清除用户数据 清除应用的用户数据\nandroid.permission.CWJ_GROUP 底层访问权限 允许CWJ账户组访问底层信息\nandroid.permission.CELL_PHONE_MASTER_EX 手机优化大师扩展权限 手机优化大师扩展权限\nandroid.permission.CONTROL_LOCATION_UPDATES 控制定位更新 允许获得移动网络定位信息改变\nandroid.permission.DELETE_CACHE_FILES 删除缓存文件 允许应用删除缓存文件\nandroid.permission.DELETE_PACKAGES 删除应用 允许程序删除应用\nandroid.permission.DEVICE_POWER 电源管理 允许访问底层电源管理\nandroid.permission.DIAGNOSTIC 应用诊断 允许程序到RW到诊断资源\nandroid.permission.DISABLE_KEYGUARD 禁用键盘锁 允许程序禁用键盘锁\nandroid.permission.DUMP 转存系统信息 允许程序获取系统dump信息从系统服务\nandroid.permission.EXPAND_STATUS_BAR 状态栏控制 允许程序扩展或收缩状态栏\nandroid.permission.FACTORY_TEST 工厂测试模式 允许程序运行工厂测试模式\nandroid.permission.FLASHLIGHT 使用闪光灯 允许访问闪光灯\nandroid.permission.FORCE_BACK 强制后退 允许程序强制使用back后退按键,无论Activity是否在顶层\nandroid.permission.GET_ACCOUNTS 访问账户Gmail列表 访问GMail账户列表\nandroid.permission.GET_PACKAGE_SIZE 获取应用大小 获取应用的文件大小\nandroid.permission.GET_TASKS 获取任务信息 允许程序获取当前或最近运行的应用\nandroid.permission.GLOBAL_SEARCH 允许全局搜索 允许程序使用全局搜索功能\nandroid.permission.HARDWARE_TEST 硬件测试 访问硬件辅助设备,用于硬件测试\nandroid.permission.INJECT_EVENTS 注射事件 允许访问本程序的底层事件,获取按键、轨迹球的事件流\nandroid.permission.INSTALL_LOCATION_PROVIDER 安装定位提供 安装定位提供\nandroid.permission.INSTALL_PACKAGES 安装应用程序 允许程序安装应用\nandroid.permission.INTERNAL_SYSTEM_WINDOW 内部系统窗口 允许程序打开内部窗口,不对第三方应用程序开放此权限\nandroid.permission.INTERNET 访问网络 访问网络连接,可能产生GPRS流量\nandroid.permission.KILL_BACKGROUND_PROCESSES 结束后台进程 允许程序调用killBackgroundProcesses(String).方法结束后台进程\nandroid.permission.MANAGE_ACCOUNTS 管理账户 允许程序管理AccountManager中的账户列表\nandroid.permission.MANAGE_APP_TOKENS 管理程序引用 管理创建、摧毁、Z轴顺序,仅用于系统\nandroid.permission.MTWEAK_USER 高级权限 允许mTweak用户访问高级系统权限\nandroid.permission.MTWEAK_FORUM 社区权限 允许使用mTweak社区权限\nandroid.permission.MASTER_CLEAR 软格式化 允许程序执行软格式化,删除系统配置信息\nandroid.permission.MODIFY_AUDIO_SETTINGS 修改声音设置 修改声音设置信息\nandroid.permission.MODIFY_PHONE_STATE 修改电话状态 修改电话状态,如飞行模式,但不包含替换系统拨号器界面\nandroid.permission.MOUNT_FORMAT_FILESYSTEMS 格式化文件系统 格式化可移动文件系统,比如格式化清空SD卡\nandroid.permission.MOUNT_UNMOUNT_FILESYSTEMS 挂载文件系统 挂载、反挂载外部文件系统\nandroid.permission.NFC 允许NFC通讯 允许程序执行NFC近距离通讯操作,用于移动支持\nandroid.permission.PERSISTENT_ACTIVITY 永久Activity 创建一个永久的Activity,该功能标记为将来将被移除\nandroid.permission.PROCESS_OUTGOING_CALLS 处理拨出电话 允许程序监视,修改或放弃播出电话\nandroid.permission.READ_CALENDAR 读取日程提醒 允许程序读取用户的日程信息\nandroid.permission.READ_CONTACTS 读取联系人 允许应用访问联系人通讯录信息\nandroid.permission.READ_FRAME_BUFFER 屏幕截图 读取帧缓存用于屏幕截图\ncom.android.browser.permission.READ_HISTORY_BOOKMARKS 读取收藏夹和历史记录 读取浏览器收藏夹和历史记录\nandroid.permission.READ_INPUT_STATE 读取输入状态 读取当前键的输入状态,仅用于系统\nandroid.permission.READ_LOGS 读取系统日志 读取系统底层日志\nandroid.permission.READ_PHONE_STATE 读取电话状态 访问电话状态\nandroid.permission.READ_SMS 读取短信内容 读取短信内容\nandroid.permission.READ_SYNC_SETTINGS 读取同步设置 读取同步设置,读取Google在线同步设置\nandroid.permission.READ_SYNC_STATS 读取同步状态 读取同步状态,获得Google在线同步状态\nandroid.permission.REBOOT 重启设备 允许程序重新启动设备\nandroid.permission.RECEIVE_BOOT_COMPLETED 开机自动允许 允许程序开机自动运行\nandroid.permission.RECEIVE_MMS 接收彩信 接收彩信\nandroid.permission.RECEIVE_SMS 接收短信 接收短信\nandroid.permission.RECEIVE_WAP_PUSH 接收Wap Push 接收WAP PUSH信息\nandroid.permission.RECORD_AUDIO 录音 录制声音通过手机或耳机的麦克\nandroid.permission.REORDER_TASKS 排序系统任务 重新排序系统Z轴运行中的任务\nandroid.permission.RESTART_PACKAGES 结束系统任务 结束任务通过restartPackage(String)方法,该方式将在外来放弃\nandroid.permission.SEND_SMS 发送短信 发送短信\nandroid.permission.SET_ACTIVITY_WATCHER 设置Activity观察其 设置Activity观察器一般用于monkey测试\ncom.android.alarm.permission.SET_ALARM 设置闹铃提醒 设置闹铃提醒\nandroid.permission.SET_ALWAYS_FINISH 设置总是退出 设置程序在后台是否总是退出\nandroid.permission.SET_ANIMATION_SCALE 设置动画缩放 设置全局动画缩放\nandroid.permission.SET_DEBUG_APP 设置调试程序 设置调试程序,一般用于开发\nandroid.permission.SET_ORIENTATION 设置屏幕方向 设置屏幕方向为横屏或标准方式显示,不用于普通应用\nandroid.permission.SET_PREFERRED_APPLICATIONS 设置应用参数 设置应用的参数,已不再工作具体查看addPackageToPreferred(String)介绍\nandroid.permission.SET_PROCESS_LIMIT 设置进程限制 允许程序设置最大的进程数量的限制\nandroid.permission.SET_TIME 设置系统时间 设置系统时间\nandroid.permission.SET_TIME_ZONE 设置系统时区 设置系统时区\nandroid.permission.SET_WALLPAPER 设置桌面壁纸 设置桌面壁纸\nandroid.permission.SET_WALLPAPER_HINTS 设置壁纸建议 设置壁纸建议\nandroid.permission.SIGNAL_PERSISTENT_PROCESSES 发送永久进程信号 发送一个永久的进程信号\nandroid.permission.STATUS_BAR 状态栏控制 允许程序打开、关闭、禁用状态栏\nandroid.permission.SUBSCRIBED_FEEDS_READ 访问订阅内容 访问订阅信息的数据库\nandroid.permission.SUBSCRIBED_FEEDS_WRITE 写入订阅内容 写入或修改订阅内容的数据库\nandroid.permission.SYSTEM_ALERT_WINDOW 显示系统窗口 显示系统窗口\nandroid.permission.UPDATE_DEVICE_STATS 更新设备状态 更新设备状态\nandroid.permission.USE_CREDENTIALS 使用证书 允许程序请求验证从AccountManager\nandroid.permission.USE_SIP 使用SIP视频 允许程序使用SIP视频服务\nandroid.permission.VIBRATE 使用振动 允许振动\nandroid.permission.WAKE_LOCK 唤醒锁定 允许程序在手机屏幕关闭后后台进程仍然运行\nandroid.permission.WRITE_APN_SETTINGS 写入GPRS接入点设置 写入网络GPRS接入点设置\nandroid.permission.WRITE_CALENDAR 写入日程提醒 写入日程,但不可读取\nandroid.permission.WRITE_CONTACTS 写系人 写系人,但不可读取\nandroid.permission.WRITE_EXTERNAL_STORAGE 写入外部存储 允许程序写入外部存储,如SD卡上写文件\nandroid.permission.WRITE_GSERVICES 写入Google地图数据 允许程序写入Google Map服务数据\ncom.android.browser.permission.WRITE_HISTORY_BOOKMARKS 写入收藏夹和历史记录 写入浏览器历史记录或收藏夹,但不可读取\nandroid.permission.WRITE_SECURE_SETTINGS 读写系统敏感设置 允许程序读写系统安全敏感的设置项\nandroid.permission.WRITE_SETTINGS 读写系统设置 允许读写系统设置项\nandroid.permission.WRITE_SMS 编写短信 允许编写短信\n```\n\n","tags":["生活"],"categories":["生活"]},{"title":"TypeScript-学习","url":"/2023/06/19/TypeScript-学习/","content":"\n\n## 浅谈 JavaScript\n\n\n\n### JavaScript 是一门优秀的编程语言吗？\n\n\n每个人可能观点并不完全一致，但是从很多角度来看，JavaScript 是一门非常优秀的编程语言；\n而且，可以说在很长一段时间内这个语言不会被代替，并且会在更多的领域被大家广泛使用；\n\n\n\n### 著名的 Atwood 定律：\n\nStack Overflow 的创立者之一的 Jeff Atwood 在 2007 年提出了著名的 Atwood 定律。\n\nany application that can be written in JavaScript, will eventually be written in JavaScript.\n\n任何可以使用 JavaScript 来实现的应用都最终都会使用 JavaScript 实现。\n\n其实我们已经看到了，这句话正在一步步被应验：\n\n\n   - Web 端的开发我们一直都是使用 JavaScript；\n   - 移动端开发可以借助于 ReactNative、Weex、Uniapp 等框架实现跨平台开发；\n   - 小程序端的开发也是离不开 JavaScript；\n   - 桌面端应用程序我们可以借助于 Electron 来开发；\n   - 服务器端开发可以借助于 Node 环境使用 JavaScript 来开发。\n\n\n\n### JavaScript 的痛点\n\n并且随着近几年前端领域的快速发展，让 JavaScript 迅速被普及和受广大开发者的喜爱，借助于 JavaScript 本身的 强大，也让使用 JavaScript 开发的人员越来越多。\n\n\n\n### 优秀的 JavaScript 没有缺点吗？\n\n其实上由于各种历史因素，JavaScript 语言本身存在很多的缺点；\n\n比如 ES5 以及之前的使用的 var 关键字关于作用域的问题；\n\n比如最初 JavaScript 设计的数组类型并不是连续的内存空间；\n\n比如直到今天 JavaScript 也没有加入类型检测这一机制；\n\n\n\n\n### JavaScript 正在慢慢变好\n\n不可否认的是，JavaScript 正在慢慢变得越来越好，无论是从底层设计还是应用层面。\n\nES6、7、8 等的推出，每次都会让这门语言更加现代、更加安全、更加方便。\n\n但是知道今天，JavaScript 在类型检测上依然是毫无进展（为什么类型检测如此重要，我后面会聊到）。\n\n\n\n### 类型带来的问题\n\n首先你需要知道，编程开发中我们有一个共识：**错误出现的越早越好**\n\n能在**写代码的时候**发现错误，就不要在**代码编译时**再发现（IDE 的优势就是在代码编写过程中帮助我们发现错 误）。\n\n能在**代码编译期间**发现错误，就不要在**代码运行期间**再发现（类型检测就可以很好的帮助我们做到这一点）。\n\n能在开发阶段发现错误，就不要在测试期间发现错误，能在测试期间发现错误，就不要在上线后发现错误。\n\n现在我们想探究的就是如何在 **代码编译期间** 发现代码的错误：\n\nJavaScript 可以做到吗？不可以，我们来看下面这段经常可能出现的代码问题。\n\n\n\n```js\nfunction getLength(str){\n  console.log(str.length)\n}\n\ngetLength('abc')\ngetLength()\n// 报错: Uncaught TypeError: Cannot read properties of undefined (reading 'length')\n```\n\n\n\n### 这是我们一个非常常见的错误：\n\n这个错误很大的原因就是因为 JavaScript 没有对我们传入的参数进行任何的限制，只能等到运行期间才发现这个 错误；\n并且当这个错误产生时，会影响后续代码的继续执行，也就是整个项目都因为一个小小的错误而深入崩溃；\n\n\n\n### 当然，你可能会想：我怎么可能犯这样低级的错误呢？\n\n当我们写像我们上面这样的简单的 demo 时，这样的错误很容易避免，并且当出现错误时，也很容易检查出来；\n\n但是当我们开发一个大型项目时呢？你能保证自己一定不会出现这样的问题吗？而且如果我们是调用别人的类\n\n库，又如何知道让我们传入的到底是什么样的参数呢？\n\n但是，如果我们可以给 JavaScript 加上很多限制，在开发中就可以很好的避免这样的问题了：\n\n比如我们的 getLength 函数中 str 是一个必传的类型，没有调用者没有传编译期间就会报错；\n\n比如我们要求它的必须是一个 String 类型，传入其他类型就直接报错；\n\n那么就可以知道很多的错误问题在编译期间就被发现，而不是等到运行时再去发现和修改；\n\n\n\n### 类型思维的缺失\n\n我们已经简单体会到没有类型检查带来的一些问题，JavaScript 因为从设计之初就没有考虑类型的约束问题，所以\n\n造成了前端开发人员关于**类型思维的缺失：**\n\n**前端开发人员**通常不关心变量或者参数是什么类型的，如果在必须确定类型时，我们往往需要使用各种判断验 证；\n\n从其他方向转到前端的人员，也会因为没有类型约束，而总是担心自己的代码不安全，不够健壮；\n\n所以我们经常会说 JavaScript**不适合开发大型项目**，因为当项目一旦庞大起来，这种宽松的类型约束会带来非常多 的安全隐患，多人员开发它们之间也没有**良好的类型契约。**\n\n比如当我们去实现一个核心类库时，如果没有类型约束，那么需要对别人传入的参数进行各种验证来保证我们 代码的健壮性；\n\n比如我们去调用别人的函数，对方没有对函数进行任何的注释，我们只能去看里面的逻辑来理解这个函数需要 传入什么参数，返回值是什么类型；\n\n\n\n### 为 JavaScript 添加类型约束的好处\n\n背景：JS 的类型系统存在“先天缺陷“，代码中绝大部分错误都是类型错误(Uncaught TypeError )。\n问题 ∶ 增加了找 Bug、改 Bug 的时间，严重影响开发效率。\n\n从编程语言的动静来区分\n\nTypeScript 属于静态类型的编程语言，JS 属于动态类型的编程语言\n\n静态类型︰编译期做类型检查；动态类型 ∶ 执行期做类型检查。\n\n代码编译和代码执行的顺序 ∶1 编译，2 执行。\n\n对于 JS 来说 ∶ 需要等到代码真正去执行的时候才能发现错误（晚）。\n\n对于 TS 来说 ∶ 在代码编译的时候（代码执行前）就可以发现错误（早）。\n\n并且，配合 VSCode 等开发工具，TS 可以提前到在编写代码的同时就发现代码中的错误，减少找 bug、改 bug 时间\n\n\n\n\n### Ts 相比 Js 的优势\n\n- 更早（写代码的同时）发现错误，减少找 Bug、改 Bug 时间，提升开发效率。\n- 程序中任何位置的代码都有代码提示，随时随地的安全感，增强了开发体验。\n- 强大的类型系统提升了代码的可维护性，使得重构代码更加容易。\n- 支持最新的 ECMAScript 语法，优先体验最新的语法，让你走在前端技术的最前沿。\n- TS 类型推断机制，不需要在代码中的每个地方都显示标注类型，让你在享受优势的同时，尽量降低了成本。\n- 除此之外，Vue 3 源码使用 TS 重写、Angular 默认支持 TS、React 与 TS 完美配合，TypeScript 已成为大中型前端项目的首选编程语言\n\n\n\n### 为了弥补 JavaScript 类型约束上的缺陷，增加类型约束，很多公司推出了自己的方案：\n\n2014 年，Facebook 推出了 flow 来对 JavaScript 进行类型检查；\n\n同年，Microsoft 微软也推出了 TypeScript1.0 版本；\n\n他们都致力于为 JavaScript 提供类型检查；\n\n而现在，**无疑 TypeScript 已经完全胜出：**\n\nVue2.x 的时候采用的就是 flow 来做类型检查；\n\nVue3.x 已经全线转向 TypeScript，98.3%使用 TypeScript 进行了重构；\n\n而 Angular 在很早期就使用 TypeScript 进行了项目重构并且需要使用 TypeScript 来进行开发；\n\n而甚至 Facebook 公司一些自己的产品也在使用 TypeScript；\n\n学习 TypeScript 不仅仅可以为我们的代码增加类型约束，而且可以培养我们前端程序员具备类型思维。\n\n\n\n## TypeScript 介绍\n\n![TypeScript 介绍](../images/tsjieshao.png)\n\n虽然我们已经知道 TypeScript 是干什么的了，也知道它解决了什么样的问题，但是我们还是需要全面的来认识一下 TypeScript 到底是什么？\n\n\n\n### 们来看一下 TypeScript 在 GitHub 和官方上对自己的定义：\n\nGitHub 说法：TypeScript is a superset of JavaScript that compiles to clean JavaScript output.\n\nTypeScript 官网：TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.\n\n翻译一下：TypeScript 是拥有类型的 JavaScript 超集，它可以编译成普通、干净、完整的 JavaScript 代码。\n\n怎么理解上面的话呢？\n\n我们可以将 TypeScript 理解成加强版的 JavaScript。\n\nJavaScript 所拥有的特性，TypeScript 全部都是支持的，并且它紧随 ECMAScript 的标准，所以 ES6、ES7、ES8 等新语法标准，它都是 支持的；\n\n并且在语言层面上，不仅仅增加了类型约束，而且包括一些语法的扩展，比如枚举类型（Enum）、元组类型（Tuple）等；\n\nTypeScript 在实现新特性的同时，总是保持和 ES 标准的同步甚至是领先；\n\n并且 TypeScript 最终会被编译成 JavaScript 代码，所以你并不需要担心它的兼容性问题，在编译时也不需要借助于 Babel 这样的工具；\n\n所以，我们可以把 TypeScript 理解成更加强大的 JavaScript，不仅让 JavaScript 更加安全，而且给它带来了诸多好用的好用特性；\n\n\n\n## TS 初体验\n\n### Ts 的编译环境\n\n在前面我们提到过，TypeScript 最终会被编译成 JavaScript 来运行，所以我们需要搭建对应的环境：\n\n我们需要在电脑上安装 TypeScript，这样就可以通过 TypeScript 的 Compiler 将其编译成 JavaScript；\n\n\n\n![TypeScript 2](../images/ts2.png)\n\n所以，我们需要全局安装\n\n\n#### 安装命令\n\n> npm install typescript -g\n\n\n\n#### 查看版本\n\n> tsc –version\n\n\n\n### TS 的运行环境\n\n如果我们每次为了查看 TypeScript 代码的运行效果，都通过经过两个步骤的话就太繁琐了：\n\n第一步：通过 tsc 编译 TypeScript 到 JavaScript 代码；\n\n第二步：在浏览器或者 Node 环境下运行 JavaScript 代码；\n\n是否可以简化这样的步骤呢？\n\n比如编写了 TypeScript 之后可以直接运行在浏览器上？\n\n比如编写了 TypeScript 之后，直接通过 node 的命令来执行？\n\n上面我提到的两种方式，可以通过两个解决方案来完成：\n\n\n\n#### 方式一：通过 webpack，配置本地的 TypeScript 编译环境和开启一个本地服务，可以直接运行在浏览器上；\n\n\n- npm init –y\n- npm i webpack webpack-cli –D\n- npm i ts-loader typescript –D\n\n\n```js\nconst path = require('path')\nmodule.exports = {\n  entry: './src/index.ts',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js'\n  },\n  resolve: {\n    extensions: ['.tsx','.ts', '.js']\n  },\n  module: {\n    rules: [\n      {\n        test: /.ts$/,\n        loader: 'ts-loader',\n        exclude: /node_modules/\n      }\n    ]\n  }\n  mode: 'development'\n}\n\n其它配置项参考webpack章节 ~\n```\n\n\n#### 方式二：通过 ts-node 库，为 TypeScript 的运行提供执行环境；\n\n安装 npm install -g ts-node\n\n另外 ts-node 需要依赖 tslib 和 @types/node 两个包：\n\nnpm install tslib @types/node -g\n\n现在，我们可以直接通过 ts-node 来运行 TypeScript 的代码：\n\nts-node index.ts\n\n注意：ts-node 7.0.0 以上就不自动识别 tsconfig.json 了，得加上 –files 才能识别\n\nts-node index.ts –files\n","tags":["TypeScript"],"categories":["前端"]},{"title":"uniapp-学习","url":"/2023/06/12/uniapp-学习/","content":"\n待更新~","tags":["uniApp"],"categories":["前端"]},{"title":"Vue3 学习","url":"/2023/06/09/Vue3-学习/","content":"\n## Vue3 简介\n\n\n![v3](../images/v3_1.png)\n\n\n* 2020 年 9 月 18 日，Vue.js 发布 3.0 版本，代号：One Piece(海贼王)\n\n* 耗时 2 年多、2600+次提交、30+个 RFC、600+次 PR、99 位贡献者\n\n* github 上的 tags 地址：https://github.com/vuejs/vue-next/releases/tag/v3.0.0\n\n\n\n\n## Vue3 带来了什么\n\n\n1. 性能的提升\n\n   * 打包大小减少41%\n   * 初次渲染快 55%, 更新渲染快 133%\n   * 内存减少 54%\n\n\n2. 源码的升级\n\n   * 使用 Proxy 代替 defineProperty 实现响应式\n   * 重写虚拟 DOM 的实现和 Tree-Shaking\n\n\n3. 拥抱 TypeScript\n\n   * Vue3 可以更好的支持 TypeScript\n\n\n4. 新的特性\n   \n   1. Composition API(组合 API)\n      \n       - setup 配置\n       - ref 与 reactive\n       - watch 与 watchEffect\n       - provide 与 inject\n       - ···\n\n\n    2. 新的内置组件\n       \n       - Fragment\n       - Teleport\n       - Suspense\n\n\n    3. 其他改变\n\n       - 新的生命周期钩子\n       - data 选项应始终被声明为一个函数\n       - 移除 keyCode 支持作为 v-on 的修饰符\n       - ···\n\n\n\n## 创建 vue3 项目\n\n```js\n  ## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上\n  vue --version\n  ## 安装或者升级你的@vue/cli\n  npm install -g @vue/cli\n  ## 创建\n  vue create vue3_study\n  ## 启动\n  cd vue3_study\n  npm run serve\n```\n\n\n## Options API 的弊端\n\n在 Vue2 中，我们编写组件的方式是 OptionsAPI：\n\nOptions API 的一大特点就是在对应的属性中编写对应的功能模块；\n\n比如 data 定义数据、methods 中定义方法、computed 中定义计算属性、watch 中监听属性改变，也包括生命 周期钩子;\n\n\n**但是这种代码有一个很大的弊端:**\n\n\n当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中；\n\n当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散；\n\n尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的（阅读组件的其他人）；\n\n\n\n**下面我们来看一个非常大的组件，其中的逻辑功能按照颜色进行了划分:**\n\n\n这种碎片化的代码使用理解和维护这个复杂的组件变得异常困难，并且隐藏了潜在的逻辑问题；\n\n并且当我们处理单个逻辑关注点时，需要不断的跳到相应的代码块中;\n\n\n\n|  OptionsAPI   | Composition API  |\n|  ----  | ----  |\n| ![OptionsAPI](../images/v3_2.png)  | ![Composition API](../images/v3_3.png) |\n\n\n\n如果我们能将同一个逻辑关注 点相关的代码收集在一起会更好。\n\n这就是**Composition API**想要做的事情，以及可以帮助我 们完成的事情。\n\n也有人把 Vue Composition API 简称为**VCA**。\n\n\n\n## 认识 Composition API\n\n那么既然知道 Composition API 想要帮助我们做什么事情，接下来看一下**到底是怎么做**呢？\n\n为了开始使用 Composition API，我们需要有一个可以实际使用它（编写代码）的地方；\n\n在 Vue 组件中，这个位置就是 setup 函数；\n\n**setup**其实就是组件的另外一个选项：\n\n只不过这个选项强大到我们可以用它来替代之前所编写的大部分其他选项；\n\n比如 methods、computed、watch、data、生命周期等等；\n\n**接下来我们一起学习这个函数的使用:**\n\n函数的参数\n\n函数的返回值\n\n\n\n### setup 函数的参数\n\n我们先来研究一个 setup 函数的参数，它主要有**两个参数:**\n\n第一个参数：props\n\n第二个参数：context\n\nprops 非常好理解，它其实就是**父组件传递过来的属性**会被放到 props 对象中，我们在**setup 中如果需要使用**,那么就可以直接通过 props 参数获取:\n\n对于定义 props 的类型，我们还是和之前的规则是一样的，在 props 选项中定义;\n\n并且在 template 中依然是可以正常去使用 props 中的属性，比如 message;\n\n如果我们在 setup 函数中想要使用 props，那么不可以通过 this 去获取（后面我会讲到为什么）;\n\n因为 props 有直接作为参数传递到 setup 函数中，所以我们可以直接通过参数来使用即可;\n\n另外一个参数是**context**,我们也称之为是一个**SetupContext**,它里面包含**三个属性:**\n\n   * **attrs：**所有的非 prop 的 attribute;\n   * **slots：**父组件传递过来的插槽(这个在以渲染函数返回时会有作用，后面会讲到);\n   * **emit：**当我们组件内部需要发出事件时会用到 emit（因为我们不能访问 this，所以不可以通过 this.$emit 发出事件）；\n\n\n\n### setup 函数的返回值\n\n   1. **若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）**\n   2. 若返回一个渲染函数：则可以自定义渲染内容。（了解）\n\n\n**注意点：**\n   1. 尽量不要与 Vue2.x 配置混用\n      - Vue2.x 配置（data、methos、computed…）中可以访问到 setup 中的属性、方法。\n      - 但在 setup 中不能访问到 Vue2.x 配置（data、methos、computed…）。\n      - 如果有重名, setup 优先。\n\n   2. setup 不能是一个 async 函数，因为返回值不再是 return 的对象, 而是 promise, 模板看不到 return 对象中的属性。（后期也可以返回一个 Promise 实例，但需要 Suspense 和异步组件的配合）\n\n\n\n### 另外注意：setup 不可以使用 this\n\n**官方关于 this 有这样一段描述**\n\n表达的含义是 this 并没有指向当前组件实例；\n\n并且在 setup 被调用之前，data、computed、methods 等都没有被解析；\n\n所以无法在 setup 中获取 this；\n\n![OptionsAPI](../images/v3_4.png)\n\n\n**其实在之前的这段描述是和源码有出入的：**\n\n之前的描述大概含义是不可以使用 this 是因为组件实例还没有被创建出来；\n\n通过阅读源码发现，代码是按照如下顺序执行的：\n\n调用 createComponentInstance 创建组件实 例；\n\n调用 setupComponent 初始化 component 内 部的操作；\n\n调用 setupStatefulComponent 初始化有状态的组件；\n\n在 setupStatefulComponent 取出了 setup 函 数；\n\n通过 callWithErrorHandling 的函数执行 setup；\n\n从上面的代码我们可以看出， **组件的 instance 肯定是在执行 setup 函数之前就创建出来了。**\n\n\n![OptionsAPI](../images/v3_5.png)\n\n\n## 响应式原理\n\n### Vue2\n\n```js\n// vue2.x 双向数据绑定原理是通过Objcet.defineProperty来实现的\n// 这种方式有缺点: 数组的长度 数组的内容发生变化检测不到\n\nlet obj = {\n  name: \"zs\",\n  age: 18,\n  phone: {\n    name: \"iphone\",\n  },\n};\n// let obj = [1, 2, 3, 4, 5]\n// 视图更新的方法\nfunction render() {\n  console.log(\"视图更新了 ~\");\n}\n\nlet methods = [\"push\", \"pop\", \"shift\", \"unshift\", \"sort\", \"reverse\", \"splice\"];\n// 将数组的原型保存一份\nlet arrProto = Array.prototype;\n// 创建原型 将数组原型拷贝一份\nlet proto = Object.create(arrProto);\n// 重写数组的方法\nmethods.forEach((method) => {\n  proto[method] = function () {\n    // AOP 面向切面编程\n    // 改变了数组的数据\n    arrProto[method].call(this, ...arguments);\n    // 重新渲染视图\n    render();\n  };\n});\n\n// 观察者模式\nfunction observe(obj) {\n  // 判断一个对象是不是数组\n  // if(Object.prototype.toString.call(obj) === '[object Array]'){\n  if (Array.isArray(obj)) {\n    // 让观测的对象的原型和我们自己重写的原型建立关系\n    obj.__proto__ = proto;\n    return;\n  }\n  // 如果观察的是一个对象的话 对其属性进行响应式监听(set、get)\n  if (Object.prototype.toString.call(obj) === \"[object Object]\") {\n    // 取出对象中的每一个键和值\n    for (let key in obj) {\n      // 调用响应式处理函数\n      defineReactive(obj, key, obj[key]);\n    }\n  }\n}\n// 观察obj对象\nobserve(obj);\n\n// 响应式处理\n// Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。\nfunction defineReactive(obj, key, val) {\n  // 检测对象的属性值是否还是对象\n  observe(val);\n  Object.defineProperty(obj, key, {\n    // 获取\n    get() {\n      return val;\n    },\n    // 设置\n    set(newVal) {\n      // 检测设置的值是不是对象\n      observe(newVal);\n      // 新值和旧值不相等的时候\n      if (newVal !== val) {\n        // 覆盖掉原来的val值\n        val = newVal;\n        // 通知render函数重新渲染视图\n        render();\n      }\n    },\n  });\n}\n\n// obj.name = 'lisi'\n// obj.age = 20\n// console.log(obj.name, obj.age);\n// 至此 基本可以实现数据发生变化 视图更新的效果\n// 但是 如果数据有多层呢 也就是属性对应的值也是对象?\n// obj.phone.name = 'huawei'\n// console.log(obj.phone.name);\n\n// 修改的值和原来的值一样 不需要重新渲染视图\n// obj.phone.name = 'iphone'\n\n// 如果重新为对象obj的phone赋值一个新的对象呢? 视图要重新渲染\n// obj.phone = {name: 'huawei'}\n\n// 并且当修改新的对象的属性值时 视图也要重新渲染\n// obj.phone.name = 'zs'\n\n// 为对象新增属性值呢? 也是没有办法监测到的\n// obj.sex = 'man'\n// $set来解决这个\nfunction $myset(obj, key, val) {\n  if (Array.isArray(obj)) {\n    return obj.splice(key, val);\n  }\n  defineReactive(obj, key, val);\n}\n// $myset(obj, 'sex', 'man')\n// 修改新增的属性值 视图也能更新\n// obj.sex = 'woman'\n\n// obj.phone = Object.assign(obj.phone, {price: '666'})\n// obj.phone.price = 888\n\n// obj.phone = {...obj.phone, ...{price: '666'}}\n// obj.phone.price = '888'\n// 以后vue涉及到给data中的对象新增属性时 有三种方式\n// 1、this.$set() || Vue.set()\n// 2、obj = Object.assign(原对象, 新对象(新增的属性:值))\n// 2、obj = {...原对象, ...新对象(新增的属性:值)}\n\n// =================== 数组 ======================\n// 数组的响应式数据处理依赖的并不是Object.defineProperty 而是对数组的能够引起数据变化的方法进行重写\n// obj.push(6)\n// obj.length ++\n// obj[0] = 88\n// $myset(obj, '0', 66)\n```\n\n\n### Vue3\n\n```js\n// vue3响应式原理利用了es6提供的proxy Api\n// 可以直接监听到对象和数组内容及长度的变化\n// 缺点: 兼容性差 支持就用proxy 不支持就用Objcet.defineProperty\nlet obj = {\n  name: \"zs\",\n  girlFriend: { name: \"刘亦菲\" },\n  arr: [1, 2, 3],\n};\n\nfunction render() {\n  console.log(\"视图重新渲染 ~\");\n}\n\nlet handler = {\n  get(target, key) {\n    // Reflect.get(target, propertyKey[, receiver])\n    // 获取对象身上某个属性的值，类似于 target[name]。\n    // 如果属性的值是一个对象的话 则重新进行代理 设置set&get\n    if (typeof target[key] == \"object\" && target[key] != null) {\n      return new Proxy(target[key], handler);\n    }\n    return Reflect.get(target, key);\n  },\n  set(target, key, val) {\n    // if(target[key] == 'length') return true\n    Reflect.set(target, key, val);\n    render();\n    // return true表示赋值成功 如果不返回true 在严格模式下可能会报TypeError\n    return true;\n  },\n};\n\nlet proxy = new Proxy(obj, handler);\n// 使用代理后的对象\n// console.log(proxy.name);\n// console.log(proxy.grilFriend);\n\n// proxy.name = 'lisi'\n// 修改深层次的对象的属性 无法监听到\n// proxy.grilFriend.name = '黄圣依'\n// console.log(proxy.name);\n// console.log(proxy.grilFriend);\n// console.log(obj.name);\n// console.log(obj.grilFriend);\n\nproxy.arr[0] = \"11\";\nproxy.arr.length++;\n// console.log(proxy.arr.length);\nconsole.log(obj.arr.length);\n```\n\n\n## reactive 函数\n\n\n- 作用: 定义一个对象类型的响应式数据（基本类型不要用它，控制台会报警告，要用 ref 函数）\n- 语法：const 代理对象= reactive(源对象)\n   - 接收一个对象（或数组），返回一个代理对象（Proxy 的实例对象，简称 proxy 对象）\n- reactive 定义的响应式数据是“深层次的”。\n- 内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。\n\n\n### 为什么就可以变成响应式的呢？\n\n这是因为当我们使用 reactive 函数处理我们的数据之后，数据再次被使用时就会进行依赖收集；\n\n当数据发生改变时，所有收集到的依赖都是进行对应的响应式操作（比如更新界面）；\n\n事实上，我们编写的 data 选项，也是在内部交给了 reactive 函数将其变成响应式对象的；\n\n","tags":["Vue"],"categories":["前端"]},{"title":"Vue2 学习","url":"/2023/06/09/Vue2-学习/","content":"\n\n## Vue 简介\n\n\nVue 是一套用于构建用户界面的 渐进式框架 。\n\n与其它大型框架不同的是，Vue 采用自底向上增量开发的设计。\n\nVue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。\n\nVue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。\n\n最初它不过是个人项目，时至今日，已成为全世界三大前端框架之一，github 上拥有 19.8万 Star。 领先于 React 和 Angular，在国内更是首选。\n\n\n\n## Vue是什么？\n\n- 定义：以数据驱动视图的MVVM渐进式框架\n   \n   - 数据：对象\n   - 视图：dom标签 –> 虚拟dom\n   - MVVM：M model模型，V view视图。就是一种框架架构，model-view view-model， 这样的结构，主要优势在于监控者数据双向绑定的特性，vue和model之间是双向数据传递的。视图改变数据就可以改变，数据改变视图就可以改变。\n   - 渐进式：轻量级框架，可以选择性的，只使用vue中很少的一部分，而不是必须使用全部\n\n\n\n### BTW——MVC和MVVM\n\n- MVVM有两个方向：\n\n   1. 将model（模型）转化成 view（视图），即后端传递的数据转化成所看到的页面。实现方式为数据绑定\n   2. 将view（视图）转化成 model（模型），即将所看的页面转化成后端的数据。实现方式为dom监听事件\n\n\n- 什么是mvc？\n\n   - MVC是model-view-controller的缩写，即模型——视图——控制器。M和V指的意思和MVVM中的M和V意思一样。C即Controller指的是页面业务逻辑。使用MVC的目的就是将M和V的代码分离。MVC是单向通信。也就是View跟Model，必须通过Controller来承上启下。\n\n\n- 区别：\n\n   - MVC和MVVM的区别并不是VM完全取代了C，只是在MVC的基础上增加了一层VM，只不过是弱化了C的概念，ViewModel存在目的在于抽离Controller中展示的业务逻辑，而不是替代Controller，其它视图操作业务等还是应该放在Controller中实现。\n   - View更新的时候，必须要通过Controller去更新一遍Model；同样的Model更新的时候，也要去更新一遍视图。\n   [!MVVM优点]:\n   实现的是业务逻辑组件的重用，使开发更高效，结构更清晰，增加代码的复用性。\n\n\n\n### vue.js核心？\n\n- 官方定义：通过尽可能简单的API实现响应的数据绑定和组合的视图组件\n\n\n\n### 数据驱动\n\n- 传统js手动改变DOM来改变视图，vue.js只需要改变数据就会自动改变视图，就是MVVM思想的实现\n\n\n\n### 视图组件化\n\n- 定义：把网页拆分一个个区块，每个区块我们可以看成一个组件。网页由多个组件拼接或嵌套组成\n\n\n\n### vue的特点\n\n- 响应式编程：编写代码基于对变化的反应\n- 组件化\n\n\n\n#### 组件和模块\n\n- 组件：把重复代码提取出来合并成为一个组件，组件最重要的是复用，位于框架最底层，其他功能依赖于组件，可供不同功能使用，独立性强\n\n- 模块：分属同一功能/业务的代码进行隔离（分装）成独立的模块，可以独立运行，以页面、功能或其他不同粒度划分程度不同的模块。位于业务框架层，模块间通过接口调用，目的是降低模块间的耦合，由之前的主应用与模块耦合，变为主应用与接口耦合，接口与模块耦合\n[比喻]模块就像有多个USB插口的充电宝，可以和多部手机充电，接口可以随意插拔。复用性很强，可以独立管理。\n\n- 组件化模块化区别？\n\n   1. 组件相当于库，把一些能在项目里或者不同类型项目中可复用的代码进行封装\n   2. 而模块相当于业务逻辑模块，把同一类型项目里的功能逻辑进行需求性的封装\n\n\n\n- 为什么要用组件和模块\n\n   - 开发和调式效率高\n   - 可维护性强\n   - 避免阻断\n   - 版本管理更容易\n\n\n\n### vue的优缺点？\n\n- 优点：轻量级框架，数据双向绑定，组件化，虚拟dom，运行速度快\n- 缺点：\n   - 不支持ie678\n   - 生态环境差不如angular和react\n   - 社区不大\n   - 无高阶书籍\n   - 首屏加载速度满，加载时，将所有的css,js文件进行加载\n\n\n\n#### BTW——首屏加载慢解决方式\n\n   - 减少入口文件体积\n   - UI框架按需引入\n   - 静态资源本地缓存\n   - 图片资源压缩\n   - 组件重复打包\n   - 使用SSR（通过对文件、目录、进程、注册表和服务的强制访问控制，有效的制约和分散了原有系统管理员的权限）\n\n\n\n#### BTW——粒度和耦合\n\n   - 粒度：计算机中常指系统内存扩展增量的最小值。粒度问题是设计数据仓库的一个最重要方面。粒度是指数据仓库的数据单位中保存数据的细化或综合程度的级别。细化程度越高，粒度级就越小；相反，细化程度越低，粒度级就越大。数据的粒度一直是一个设计问题。\n   - 耦合：两个东西通过某种作用连接在了一起\n\n\n\n## vue核心的底层原理\n\n   - Object.defineProperty数据劫持的API\n\n   - Object.defineProperty定义新属性或修改原有的属性，vue的数据双向绑定原理就是Object.defineProperty，里面定义了setter和getter方法，通过观察者模式(发布订阅模式)来监听数据变化，从而做相应的逻辑处理\n\n   - 监听对象属性变化，只关心数据不关心视图\n\n   - 三个参数- 三个参数Object.defineProperty(object,propName,descriptor)\n\n      - object 对象=>给谁加\n      - propName 属性名=>需要加的属性的名字[类型:String]\n      - descriptor 属性描述=>加的这个属性有什么特性[类型：Object]\n      - 方法就是直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象\n\n   - 属性描述符\n\n      - configurable: true 配置可删除，默认false\n\n         * 两个作用：\n\n            1. 目标属性是否可以使用delete删除\n            2. 目标属性是否可以再次设置特性\n\n      - writable：true 配置可修改，默认false\n      - enumerable:true 可枚举，使用(for…in或Object,keys())默认false\n      - value属性对应的值，可以是任意类型的值，默认undefined\n      - 缺点：数组的长度\n\n\n#### 语法\n\n```js\n// writable应用\n    let Person = {}\n    Object.defineProperty(Person,'name',{value:'Jack',\n        // writable:true // 加上这个就可以输出{name:'Rose'}\n    })\n    console.log(Person) // {name:'Jack'}\n    Person.name = 'Rose'\n    console.log(Person) //undefined,因为writable默认false\n// enumerable应用\n    var user={name:'小五',age:'24'};\n    // es6\n        var keys = Object.keys(user)\n        console.log(keys) // ['name','age']\n    // es5\n        var Key = []\n        for(key in user) {\n            Key.push(Key)\n        }\n        console.log(Key) // ['name','age']\n// configurable应用\n    var human={name:'李白',age:'不详'}；\n    // 定义一个性别，不可被删除和重新定义特性\n        Object.defineProperty(human,'gender',{\n            value:'男',\n            enumerable:true,\n            configurable:false\n        })\n    // 删除一下\n        delete human.gender\n        console.log(human)//{name:\"李白\",age:\"不详\",gender:\"男\"} 并没有删除\n    // 重新定义特性\n        Object.defineProperty(human,'gender',{\n            value:'男',\n            enumerable:true,\n            configurable:true\n        })\n        delete human.gender;\n        console.log(human) // {name:\"李白\",age:\"不详\"}\n```\n\n\n- 存取描述符\n\n> get\n一个给属性提供 getter 的方法，如果没有getter则为undefined。该方法返回值被用作属性值。默认为undefined。getter就是获取属性值\n> set\n一个给属性提供 setter 的方法，如果没有setter则为undefined。该方法将接收唯一参数，并将该参数的新值分配给属性。默认为undefined。setter就是设置属性值\n[!注意]：1. 当使用getter或setter方法，不允许使用writable和value这两个属性\n2. get或set不是必须成对出现，任写其一就行。如果不设置方法，get和set默认undefined\n\n\n#### 语法\n\n```js\nvar username = {name:\"不想起名了\"};\nvar num = 12\n// 定义一个age获取值时返回定义好的变量\n    Object.defineProperty(username,'age',{\n        get:function() {\n            return num\n        }\n    })\n    console.log(username.age);//12\n// 定义一个age获取值时返回定义好的变量num\n    Object.defineProperty(username,'age',{\n        get:function() {\n            return num\n        }\n        set:function(newVal) {\n            num = newVal\n        }\n    })\n    console.log(username.age);// 12\n    username.age = 145\n    console.log(username.age); // 145\n    console.log(num); // 145\n```\n\n- 兼容性：IE8以下不行\n- 使用Object.defineProperty的优点\n   1. 减少代码（少了dom,不需要写很多dom）\n   2. 开发速度快\n\n\n#### BTW——数据劫持\n\n- 定义：修改或访问对象的属性时，通过一段代码拦截这个行为，进行额外的操作或者修改返回结果\n\n\n\n## vue环境搭建\n\n- 环境需要:nodejs 检测cmd:node-v\n- 安装全局脚手架:npm i -g @vue/cli 检测：vue-Vyarn global add @vue/cli\n- 脚手架网站:cli.vuejs.org\n- vue官网: vuejs.org\n\n\n### 创建vue项目\n\n> 【注意】:项目名称不能是中文，不能是大写字母，不能用vue做名字\n\n\n#### 命令运行方式\n\n<table><td bgcolor=#7FFFD4><font color=#FF0000 >vue create name</font></td></table>\n\n\n\n#### gui图形化方式\n\n<table><td bgcolor=#7FFFD4><font color=#FF0000 >vue ui</font></td></table>\n\n\n\n### vue脚手架\n\n   - 定义:vue的cli脚手架底层是webpack,也就是基于webpack封装的\n\n   [官网] (https://cli.vuejs.org/zh/guide/)\n\n\n\n### BTW——是脚手架？\n\n1. 什么是脚手架？\n   - 构建基于数据库的应用，进行增、删、改、查数据库的操作\n2. Vue-CLi是什么？\n   - 是vuejs脚手架工具，就是自动帮你生成好项目目录，配置好webpack，以及各种依赖包工具\n   - 为什么要用？可以帮助你快速开启一个vue项目，给你一套文件结构，包含基础的依赖库，只需要npm install 一下就可以安装，不需要为编译或其他琐碎事而浪费时间，而且不会限制到你发挥\n\n\n\n### 脚手架配置\n\n- vue.config.js文件是脚手架配置文件，该文件必须放在项目的根目录里\n\n\n\n#### 请求代理【跨域方案】\n\n脚手架->webpack->nodejs【后端】\n使用后端转发请求\n【注意】只能在开发环境中使用\n【使用场景】在公司里和后端的测试接口进行接口调式使用\n\n\n#### 语法\n```js\nmodule.exports={\n    devServer:{\n        // 浏览器自动打开\n        open:true,\n        // 代理\n        proxy:{\n            \"/api\":{\n                target:\"http://xx.com\",\n                changeOrigin:true,\n                pathRewrite:{\n                    \"^/api\":\"\",\n                },\n            },\n        },\n    }\n}\n```\n\n\n#### 关闭源码映射【性能优化】\n\n- productionSourceMap:false\n  打包的时候，每一个js文件对应生成一个map源码映射文件，它在生产环境中时没有用的。它会增加打包时间，浪费磁盘空间，以及容易造成代码泄漏等问题，因此需要在生产环境中关闭，只允许开发环境中开启\n\n\n\n#### 关闭eslint代码校验\n\n- lintOnSave:false\n\n\n\n### AIA：脚手架配置有哪些？\n\n1. 代码校验\n2. 代码映射的开启与关闭\n3. 请求代理vue.config.js\n\n\n\n## vue项目结构\n\n### 运行命令\n\n\n- 项目根目录里有一个package.json文件，该文件有一个script对象，里面就是自定义运行命令。（是这三个里唯一一个可以删的）\n- serve开发环境，写代码时的环境\n- build生产环境，打包发布时的环境\n\n\n\n### 结构\n\n- node_modules它是项目运行时必须依赖\n- public公共目录，存放着唯一的html模板\n- src【核心-源码】项目所有代码\n- .gitignore过滤掉git仓库里不需要的文件清单\n- babel.config.js把es6转成es5\n- package.lock.json(可以删但一般留着)，锁定依赖版本号\n- package.json【核心】依赖包管理文件\n- README.md说明书\n\n\n\n#### src源码结构\n\n- assets存放静态资源：图片，css,js脚本\n- component放组件\n- App.vue根组件，第一个被加载的组件\n- main.js入口文件，第一个被执行的文件\n\n\n\n### 模块化开发【vue核心亮点】\n\n把一切重复使用的资源，无论是图片，样式还是js代码抽离出来，作为单独的’模块’进行复用\n\n- 模块包含：vue 组件，图片，js 脚本，css 样式，字体等都可以是模块。\n\n\n\n### vue里的模块化组件开发\n\n1. 组件必须使用import引入到当前组件\n2. 当前组件的components必须挂载引入的组件\n3. 在当前组件的template里用标签的形式使用挂载的组件\n\n\n\n## 插值\n\n- 渲染文本\n- 写在两个大括号中间\n\n\n### 插值语法可以写哪些值\n\n- 对象、字符串、数字、数组、布尔值、三元表达式、自执行函数等，凡是具有返回值的都可以，全部变成文本渲染出来\n\n\n\n### BTW——自执行函数和快速删除文件\n\n#### 自执行函数后面+（）\n\n```js\n{function(){return 1000()}}\n```\n\n\n### 为什么用自执行函数而不是函数\n\n用函数也可以，只不过返回时function(){return 1000},而不是1000\n\n\n\n### 插值语法的作用\n\n   1. 四则运算 100+(200*300)/2\n   2. 插值里存放变量 (详情请找baseVue.html)\n\n\n#### npkill和rimraf快速删除node_modules包\n\n   1. 全局安装npm i -g npkill\n   2. 进入想清理的文件夹\n   3. cd文件路径\n   4. 输入npkill\n   5. 会自动查找文件中node_modules\n   6. 光标上下移动来选择要清理的目录，释放宝贵的空间\n   7. 按空格删除\n\n\n\n## 内置方法\n\n### $set添加或修改对象和数组\n\n\n- 添加/修改对象的属性 $set(obj,'name',1)\n- 添加或修改数组成员$set(arr,index,val)\n\n\n### $delete删除对象和数组\n\n- 删除对象属性$delete(obj,name)\n- 删除数组成员$delete(arr,index)\n\n\n### $emit派发一个动作向上级通信\n\n\n### $mount手动挂载方法","tags":["Vue"],"categories":["前端"]},{"title":"小程序 学习","url":"/2023/06/09/小程序-学习/","content":"\n\n## 浅谈小程序\n\n  在 2016 年的「微信公开课 Pro」演讲中，微信事业群总裁张小龙这样描述了小程序的前景与未来：\n\n> \" 小程序是一种不需要下载安装即可使用的应用，它实现了应用 “触手可及” 的梦想，用户扫一扫或者搜一下即可打开应用。也体现了 “用完即走” 的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无须安装卸载 \"。\n\n\n  小程序刚发布的时候要求压缩包的体积不能大于 1M，否则无法通过，在 2017 年 4 月做 了改进，由原来的 1M 提升到 2M；\n\n  2017 年 1 月 9 日 0 点，万众瞩目的微信第一批小程序正式低调上线。\n\n  而在 2020年的「WWDC 苹果全球开发者大会」中，轻应用则被作为 iOS 14 的主要功能进行强调与推介：\n\n\n\n  ![你好](../images/wx1.png)\n\n\n> App Clip 就是一种无需用户在 iPhone 或 iPad 上安装完整的应用程序，就可以访问使用该应用程序的部分功能的轻量级应用，它们专注于处理简单快速的任务。\n\n\n\n不论是张小龙对「微信小程序」略带文艺的描述，还是在 WWDC 上对于「轻应用」在 iOS 生态中的地位描述，我们都能大抵能理解小程序诞生的初衷。而如果我们把时间从这两场发布会的转至今日，却会发现小程序早已不再局限于「用完即走」与「快速打开」，各式各样的小程序已呈现百花齐放的状态，不论是工具小程序，内容小程序，交易小程序，直播小程序，各种类型应有尽有。\n\n不妨让我尝试用自己的工作日常举例，早上出门上班，我会打开「天府健康通」扫描地铁场所码，并把健康码给地铁安检查看，临近中午 11 点 30 分，我会用「美团」或「饿了么」为自己订一份工作餐，吃完午饭后我会打开「动物餐厅」看看小猫咪又赚了多少小鱼干，下午会议时使用「腾讯文档」查看会议纪要，快下班的时候用「叮咚买菜」购置晚饭所需的食材，晚上回家做饭时，用「懒饭 App」看看想吃的番茄肥牛饭怎么做。\n\n\n\n![你好](../images/wx2.png)\n\n\n\n时至今日，当我们说到小程序时，也不仅仅在特指微信小程序，各式各样的平台都纷纷推出了自己专属的小程序平台，不论支付宝、字节跳动、美团还是百度等其他互联网大厂，都纷纷推出了自己专属的小程序平台，且都基于自己的生态业务，为小程序提供流量进行支持，希望用户与开发者能够选择自有平台中的小程序进行开发。\n\n随着小程序业务的愈演愈烈，越来越多的流量都被引入了互联网巨头的小程序战场中，但在这个过程中，对于战场中「封闭，不透明」的吐槽与争议也逐渐出现，无数企业都希望自己的应用中也能具备运行小程序的能力，希望能够借此抗争小程序被引入寡头所控制的战场，但「知易行难」，快速完成对小程序的底层与容器的研发，所需要花费的精力与时间并不是短时间就能够完成的。\n\n事实上，小程序可以被理解为是「移动应用 App」的一个细分子集，如果按照「平等透明」的设想，小程序不应该仅仅存在于微信之中，那些我们并不经常使用的应用都可以通过小程序进行重新优化，我们可以通过各式各样的专门应用打开相关的小程序，从而对那些「太重的应用」进行减负操作。\n\n当然了，小程序还会有这样一些特性需要我们注意：\n\n\n\n* 小程序不具备「被关注」的能力，获取流量留存用户的操作需要由独立应用或其他渠道完成;\n\n* 小程序不具备「推送消息与群发消息」的能力，对用户的信息触达与消息传递的操作需要由其他渠道完成;\n\n* 小程序不具备「跨 App 分享 」的能力，因此对于小程序的分享与打开路径，需要在设计产品时提前思考，而不是把鸡蛋放在一个篮子里;\n\n\n\n\n\n### 什么样的应用适合使用小程序开发\n\n\n虽然小程序市场时至今日依然是一片蓝海，但我想也不是所有应用「都可以，都应该」使用小程序开发的。\n\n基于我们的经验与积累来说，符合「逻辑简单，使用低频，对性能要求不极致」的应用场景，更加适合使用小程序进行研发。\n\n\n\n\n#### 逻辑简单：\n\n是指应用的操作逻辑并不十分复杂，各类生活服务（如打车，订餐，查地图与导航等等）都需要给用户提供简单清晰的操作逻辑，而这一类也天然的符合起初小程序「用完即走」的定义，因此十分符合使用小程序研发。一些逻辑复杂的应用场景想要通过小程序进行适配，就可能会面临更多的设计与研发困难，同时在性能和体验也可能会面对更多需要解决的问题。\n\n\n\n#### 使用低频：\n\n是指小程序的使用频率不应该太高，比如社交类的钉钉或飞书，金融类的掌上生活或浦大喜奔，媒体类的网易云音乐或斗鱼都不太适合使用小程序进行重新设计。对于用户使用的频率较高的应用来说，直接打开应用进行体验的步骤肯定最快的，此外由于某些行业的特殊性质（比如具备交易，支付等能力）要求，对于安全性与保密性的首选风险判断原则，也不宜使用常见的小程序进行设计。\n\n\n\n#### 对性能要求不极致：\n\n是指由于小程序始终存在于某个独立应用（也被称为宿主应用）中，考虑到目前的性能与研发所限制，暂时不太适合开发对于这两者有更高要求的移动应用。比如把原神，王者荣耀这样的游戏应用通过小程序进行重新设计，在目前来说肯定是不现实的。\n\n当然，随着相关研发实力的增强与产业生态的逐渐补充，也有越来越多的「不可能」变为了「可能」，比如华西证券的「华彩人生」，浦发银行的「浦大喜奔」，某省的移动警务平台等客户都选择使用小程序容器方案进行落地实现\n\n\n\n\n### 小程序与 H5，原生应用有何区别？\n\n很多朋友在了解小程序技术的时候，都会有这样的疑惑“到底与 H5，原生应用”这些技术相比，小程序具有哪些优势与劣势呢？\n\n\n\n\n#### H5 移动应用\n\n我们常说的 H5 其实也通常可以被视为一种 Web App，相比于我们在桌面端浏览器中打开的网页，主要是增加了一些响应式的设计与交互优化，从而使得这些网页更适合在移动端的浏览器中显示运行。既然是网页应用，那依然是基于 JavaScript，CSS 和 HTML 进行实现的，由于是基于各类前端技术栈进行实现，最大的好处就是快速、简单、方便，且有各种技术资料可以参考。\n\n同样，H5 的缺点与优点也是并存的，比如由于技术已经很成熟了，对于前端经验欠缺的新人来说，面对各式各样的框架，模块、任务管理工具，UI 库可能会出现无从下手的问题；此外相比于原生应用，对于系统权限的获取（比如数据缓存能力，网络通信状态等）都显得比较鸡肋，当低性能的设备加载包含复杂逻辑的页面时，会出现明显的卡顿与延迟问题。\n\n\n\n#### 原生应用\n\n原生应用也被叫做 Native App，相比于 H5 应用通过前端三大件进行实现不同，原生应用主要会采用 iOS 与 Android 的专有语言 Object-C（或 Swift），Java（或 Kotlin）进行实现，大多我们所常见的国民应用，比如微信，支付宝等都属于这种原生应用。\n\n既然被叫做「原生应用」，就像操作系统的亲儿子一样，天然在性能与体验上具备优秀的潜质，也有组件库丰富，接口支持完善等各种优势特点。但原生应用最大的缺陷就是不能跨平台研发，以目前的主流市场为例，必须要支持 iOS 与 Android 两个主流平台。\n\n\n\n\n#### 混合应用\n\n混合应用一般被称为 Hybrid App。简单来说，混合应用就是将原生功能封装成对应的 JS 接口，在前端使用 H5 来开发对应的 App （即 H5 作为内容+原生应用作为壳） ，看上去虽然是一个移动原生应用整体，但实际的页面还是网页，一套代码可以生成 iOS 与 Android 两种安装包，开发成本较低。\n\n我们常见的淘宝，京东等应用由于更新与优化节奏都十分快速，为了更好的响应「贴近用户」的目标，应用中有的功能通过原生 Native 实现，有的功能则通过 H5 页面进行实现，这种应用就属于我们所说的混合应用。\n\n\n\n#### 小程序\n\n严格意义上来说，小程序并不属于以上 3 种应用的任何一种。小程序主要通过 JavaScript 与 CSS 这种常见的前端技术进行开发，但又没有完全使用 HTML 进行实现，在不同的操作系统中，JavaScript 代码分别运行在 iOS 的 JavaScriptCore 与 Android 的 X5 JSCore 中，各家小程序平台或多或少都有一部分自研的核心，因此渲染视图层的组件也有所不同。\n\n\n\n![你好](../images/wx3.png)\n\n\n相比「 H5 移动应用」与「 移动原生应用」，小程序具备如下优势：\n\n\n  - 具备跨平台的能力，一套代码可以在 iOS 与 Android 两个平台中运行；\n  - 远超过 H5 的体验（支持本地缓存，Webview，有丰富的组件与支持库）；\n  - 能获取更多系统权限，完成更加丰富的产品设计；\n  - 可以避免 DOM 泄露（不使用常用的 window 对象与 document 对象）；\n  - 开发简单，上手成本低（比如 FinClip 提供了 FIDE 与开发文档）；\n\n\n\n\n\n#### 常见的小程序开发框架有哪些\n\n以主要的小程序开发框架举例，腾讯云社区的「极乐君」将不同平台下小程序支持的力度整理在一张表中：\n\n\n![你好](../images/wx4.png)\n\n\n\n## 小程序开发环境\n\n\n1、[微信文档](https://developers.weixin.qq.com/miniprogram/dev/framework/)\n\n2、[微信开发工具下载](https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html)\n\n3、[注册小程序账号](https://mp.weixin.qq.com/)\n\n\n\n![账号分类](../images/wx5.png)\n\n\n![小程序注册](../images/wx6.png)\n\n\n\n## 小程序特点\n\n\n1. 没有 DOM\n\n2. 组件化开发： 具备特定功能效果的代码集合\n\n3. 体积小，单个压缩包体积不能大于 2M，否则无法上线\n\n4. 小程序的四个重要的文件\n\n   - .js —> js 逻辑 —> js\n   - .wxml —> view 结构—–> html\n   - .wxss —> view 样式 —–> css\n   - .json —-> view 配置—– > json 文件\n\n\n\n5. 小程序适配方案: rpx (responsive pixel 响应式像素单位)\n\n- 小程序适配单位： rpx\n- 规定任何屏幕下宽度为 750rpx\n- 小程序会根据屏幕的宽度不同自动计算 rpx 值的大小\n- Iphone6 下： 1rpx = 1 物理像素 = 0.5px\n\n\n\n![尺寸单位](../images/wx7.png)\n\n\n\n\n## 小程序配置\n\n\n### 全局配置\n\n> 作用： 用于为整个应用进行选项设置\n\n\n![全局配置](../images/wx8.png)\n\n\n\n### 页面配置\n\n\n    配图参上\n\n    作用：用于为指定的页面进行配置\n\n    注：页面配置的优先级高于全局配置\n\n\n\n### sitemap 配置\n\n\n   配图参上\n\n   作用：配置其小程序页面是否允许微信索引\n\n\n\n\n## 小程序基础\n\n\n### 框架接口\n\n![框架接口](../images/wx9.png)\n\n\n\n#### App\n\n\n   1. 全局 app.js 中执行 App()\n   2. 生成当前应用的实例对象\n   3. getApp()获取全局应用实例\n\n\n\n\n#### Page\n\n\n   1. 页面.js 中执行 Page()\n   2. 生成当前页面的实例\n   3. 通过 getCurrentPages() 获取页面实例\n\n\n\n\n### WXML 语法\n\n\n![WXML 语法](../images/wx10.png)\n\n\n> 具体看官方文档 ~\n\n\n\n#### ToDoList\n\n- todolist.wxml\n\n\n\n```js\n<view class=\"container\">\n    <view class=\"header\">\n        <input type=\"text\" class=\"header-input\"\n        bindinput=\"inputHandler\"\n        value='{{text.title?text.title:\"\"}}'/>\n        <button type=\"primary\" size=\"mini\"\n        bindtap=\"add\">添加</button>\n    </view>\n\n    <view class=\"show\" wx:if=\"{{todoList.length > 0}}\">\n        <view wx:for=\"{{todoList}}\" wx:key=\"id\">{{item.id + 1}}. {{item.title}}\n        <button type=\"warn\"\n        size=\"mini\"\n        bindtap=\"del\"\n        data-index=\"{{index}}\"\n        >删除</button>\n        </view>\n    </view>\n\n    <view wx:else>暂无待办事项</view>\n</view>\n```\n\n\n\n- todolist.js\n\n\n```js\nPage({\n  /**\n   * 页面的初始数据\n   */\n  data: {\n    todoList: [\n      { id: 0, title: \"吃饭\" },\n      { id: 1, title: \"睡觉\" },\n      { id: 2, title: \"打豆豆\" },\n    ],\n    // 保存用户输入的数据\n    text: \"\",\n  },\n  // 用户输入数据后会触发的回调\n  inputHandler(e) {\n    // 保存用户输入的数据\n    this.setData({\n      text: {\n        id: this.data.todoList.length,\n        title: e.detail.value,\n      },\n    });\n  },\n  // 添加\n  add() {\n    // 修改数据并且清空输入框\n    this.setData({\n      todoList: [...this.data.todoList, this.data.text],\n      text: \"\",\n    });\n  },\n  // 删除\n  del(e) {\n    // 获取传过来的索引\n    // console.log(e.target.dataset.index)\n    var index = e.target.dataset.index;\n    // 删除数据\n    this.data.todoList.splice(index, 1);\n    // 只要修改了数据 一定要重新setData\n    this.setData({\n      todoList: this.data.todoList,\n    });\n  },\n});\n```\n\n- todolist.wxss\n\n```js\n.container {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n}\n.header {\n    display: flex;\n    margin-top: 20rpx;\n}\n.header-input {\n    height: 64rpx;\n    line-height: 64rpx;\n    border: 1px solid #000;\n    text-align: center;\n    margin-right: 20rpx;\n}\n.show {\n    margin-top: 20rpx;\n}\n```\n\n\n\n#### Tab\n\n- tab.wxml\n\n\n```js\n<view class=\"container\">\n  <view\n    class=\"tab {{index == current ? 'active' : ''}}\"\n    bindtap=\"changeCurrent\"\n    data-index=\"{{index}}\"\n    wx:for=\"{{tabList}}\"\n    wx:key=\"*this\"\n  >\n    <text>{{ item }}</text>\n  </view>\n</view>\n```\n\n\n- tab.js\n\n\n```js\nPage({\n  /**\n   * 页面的初始数据\n   */\n  data: {\n    tabList: [\"首页\", \"购物车\", \"我的\"],\n    current: 0,\n  },\n  changeCurrent(e) {\n    // 在事件处理函数中，通过 event.target.dataset.参数名 即可获取到具体参数的值\n    console.log(e.currentTarget.dataset.index);\n    this.setData({\n      current: e.target.dataset.index,\n    });\n  },\n});\n```\n\n\n- tab.wxss\n\n```js\n.container {\n    display: flex;\n    justify-content: space-around;\n}\n.tab {\n    text-align: center;\n    width: 200rpx;\n    border: 1px solid black;\n}\n.active {\n    border-bottom: 2px solid red;\n}\n```\n\n\n\n#### target 和 currentTarget 的区别？\n\n> target 是触发该事件的源头组件，而 currentTarget 则是当前事件所绑定的组件\n\n\n![target 和 currentTarget 的区别](../images/wx11.png)","tags":["微信小程序"],"categories":["前端"]},{"title":"NodeJs 学习","url":"/2023/06/08/NodeJs-学习/","content":"\n\n\n\n## node.js 介绍\n\n### node.js 是什么？\n\n  1. node.js 是一个开发平台，就像Java开发平台、.Net开发平台、PHP开发平台、Apple开发平台一样。\n   - 何为开发平台？有对应的编程语言、有语言运行时、有能实现特定功能的API(SDK：Software Development Kit)\n\n  2. nodejs平台使用的编程语言是 JavaScript 语言。\n   - 不支持 window、document、bom 对象。\n\n  3. node.js平台是基于 Chrome V8 JavaScript 引擎构建。\n\n  4. 基于 node.js 可以开发控制台程序(命令行程序、CLI程序)、桌面应用程序(GUI)(借助 node-webkit、electron 等框架实现)、Web 应用程序(网站)。\n\n  > PHP开发技术栈: LAMP - Linux Apache MySQL PHP\n  > node.js 全栈开发技术栈: MEAN - MongoDB Express Angular Node.js\n\n\n### node.js 有哪些特点？\n\n  1. 事件驱动(当事件被触发时，执行传递过去的回调函数)\n  2. 非阻塞 I/O 模型(当执行I/O操作时，不会阻塞线程)\n  3. 单线程\n  4. 拥有世界最大的开源库生态系统 —— npm。\n\n\n### node.js 网站\n\n  1. [node.js官方网站](https://nodejs.org/en)\n  2. [node.js中文网](https://nodejs.cn/)\n  3. [node.js中文社区](https://cnodejs.org/)\n\n\n### 学习目标\n\n  1. 了解服务器开发过程\n  2. 会使用 node.js 开发基本的 http 服务程序(Web应用程序)\n\n\n### Node.js可以用来做什么？\n\n  * 具有复杂逻辑的动态网站\n  * WebSocket服务器\n  * 命令行工具\n  * 带有图形界面的本地应用程序\n  * ···\n\n\n\n## 终端基本使用\n\n### 打开应用\n\n  * notepad 打开记事本\n  * mspaint 打开画图\n  * calc 打开计算机\n  * write 打开写字板\n  * sysdm.cpl 打开环境变量设置窗口\n\n\n### 常用命令\n\n  * md 创建目录\n  * rmdir(rd) 删除目录，目录内没有文档\n  * echo on a.txt 创建空文件\n  * del 删除文件\n  * rm 文件名 删除文件\n\n\n\n### Node.js开发环境准备\n\n1. 普通安装方式[官方网站](https://nodejs.org/zh-cn)\n\n2. 多版本安装方式\n\n  * 卸载已有的Node.js\n  * 下载nvm\n  * 在C盘创建目录dev\n  * 在dev目中中创建两个子目录nvm和nodejs\n  * 并且把nvm包解压进去nvm目录中\n  * 在install.cmd文件上面右键选择【以管理员身份运行】\n  * 打开的cmd窗口直接回车会生成一个settings.txt文件，修改文件中配置信息\n  * 配置nvm和Node.js环境变量\n\n   > NVM_HOME:C:\\dev\\nvm\n   > NVM_SYMLINK:C:\\dev\\nodejs\n\n  * 把配置好的两个环境变量加到Path中\n\n\n\n### nvm常用的命令\n  - nvm list 查看当前安装的Node.js所有版本\n  - nvm install 版本号 安装指定版本的Node.js\n  - nvm uninstall 版本号 卸载指定版本的Node.js\n  - nvm use 版本号 选择指定版本的Node.js\n\n\n\n### Node.js之HelloWorld\n\n  - 命令行方式REPL\n  - 运行文件方式\n  - 全局对象概览\n\n\n\n### Node.js 开发 Web 应用程序 和 PHP、Java、ASP.Net等传统模式开发Web应用程序区别\n\n1. #### 传统模式\n\n  * 有 Web 容器\n\n![有Web容器开发模型](../images/Web.png)\n\n\n2. #### Node.js 开发 Web 应用程序\n\n  * 没有 Web 容器\n\n![没有Web容器开发模型](../images/nodejs10.png)\n\n\n\n\n## 在 node.js 上编写程序\n\n### REPL 介绍\n\n1. REPL 全称: Read-Eval-Print-Loop(交互式解释器)\n\n - R 读取 - 读取用户输入，解析输入了 Javascript 数据结构并存储在内存中。\n - E 执行 - 执行输入的数据结构\n - P 打印 - 输出结果\n - L 循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。\n\n2. 在 REPL 中编写程序 (类似于浏览器开发人员工具中的控制台功能)\n\n  - 直接在控制台输入 node 命令进入 REPL 环境\n\n\n3. 按两次 Control + C 退出 REPL 界面 或者 输入 .exit 退出 REPL 界面\n\n  - 按住 control 键不要放开, 然后按两下 c 键\n\n\n\n### 创建 JavaScript 文件编写程序\n\n#### JavaScript 文件名命名规则\n\n  * 不要用中文\n  * 不要包含空格\n  * 不要出现 node 关键字，比如：node.js\n  * 建议以 ‘-’ 分割单词\n\n\n### 案例 1：编写一个简单的函数, 实现数字相加\n\n```js\nvar n = 10;\nvar m = 100;\n\nfunction add(x, y) {\n  return x + y;\n}\n\nvar result = add(m, n);\n\nconsole.log(\"计算结果是：\" + result);\n```\n\n\n\n### 案例 2：文件读写案例\n\n\n\n\n\n\n\n# NodeJs笔记\n\n## 浏览器渲染过程\n1、HTML解析器会将HTML标记 生成DOM树\n2、将CSS标记生成CSS规则树\n3、将DOM与CSS规则树合并成一个render树\n4、根据render树来布局，计算每个节点的几何信息\n5、将各个节点绘制到浏览器上\n\n## 浏览器访问过程\n输入URL访问\n浏览器构建请求行\n查找强缓存\nDNS解析\n客户端与服务端进行TCP三次握手连接\n在TCP连接的基础上发送HTTP请求\n服务端处理请求并返回HTTP报文\n浏览器解析渲染页面\n连接结束，四次挥手断开连接\n\n## 回流重绘\n回流\n当元素尺寸，位置或者内容，或者触发伪类等操作使得样式发生变化导致浏览器 DOM 发生变化的时候会发生浏览器回流，回流的代价很高，有时候一个 DOM 回流可能会导致多个节点发生回流\n重绘\n当浏览器样式发生改变但并不影响 DOM 布局的时候，会发生浏览器重绘，例如 color ， background 等改变就会触发浏览器的重绘。\n\n## documentFragment是什么\ndocumentFragment是一个保存多个element的容器对象（保存在内存）当更新其中的一个或者多个element时，页面不会更新。只有当documentFragment容器中保存的所有element更新后再将其插入到页面中才能更新页面。\n列如将ul里面的li取出放到documentFragment,更新完毕后再将其插入到ul,一共有以下四步骤：\n创建documentFragment对象fragment\n取出ul中的所有子节点并保存到fragment\n更新fragment中的所有节点（li的内容）\n将fragment插入到ul\n\n## 事件轮询？(EventLoop)\n一个用来等待和发送消息和事件的程序结构。\n1、所有任务都在主线程上执行，形成一个执行栈。\n2、主线程发现有异步任务，如果是微任务就把他放到微任务的消息队列里，如果是宏任务就把他\n放到宏任务的消息队列里。\n3、执行栈所有同步任务执行完毕。\n4、执行微任务队列，之后再执行宏任务队列。\n5、轮询第4步。\n\n## 引入读写文件的模块\n```js\nconst fs = require('fs')\n```\n## 写文件\n- fs.writeFile(参数1,参数2,参数3,参数4) //替换\n参数1：要写入的文件路径，必填。\n参数2：要写入的数据，必填。可以是字符串类型或者buffer类型\n参数3：写入文件时的选项，比如：文件编码，选填。默认是utf8\n参数4：文件写入完毕后的回调函数，必填。\n\n- fs.appendFile() //追加\n\n```js\nfs.writeFile('./demo.txt', JSON.stringify(msg), (err)=> {\n  if(err) {\n    console.log(err)\n    return \n  }\n  console.log('数据写入成功 ~')\n})\n```\n\n## 读文件\nfs.readFile(参数1,参数2,参数3) //读取\n参数1：要读取的文件路径，必填。\n参数2：读取文件时的选项，比如：文件编码。选填。\n参数3：文件读取完毕后的回调函数，必填。\n```js\nfs.readFile('./demo.txt','utf8', (err, data)=> {\n  if(err) return console.log(err)\n  console.log(data)   // 默认读取出来的数据是buffer数据类型我们需要将其转换文字符串类型\n})\n```\n\n## __dirname 和 __filename\n```js\n console.log(__dirname); //获取当前js文件所在的路径\n console.log(__filename); //获取当前js文件所在的路径 + 文件名\n```\n\n## 创建文件\nfs.mkdir(参数1,参数2)\n参数1：创建文件的路径，必填\n参数2：回调函数，必填\n```js\nfs.mkdir(__dirname + '/aaa',(err)=>{\n  if (err) {\n    console.log('创建目录出错了，详细信息如下：');\n    console.log(err);\n  } else {\n    console.log('目录创建成功！');\n  }\n\n});\n```\n\n## try\n异步操作无法通过 try-catch 来捕获异常，要通过判断 error 来判断是否出错。\n\n```js\ntry { \n  fs.readFile('./demo.txt','utf8', (err, data)=> {\n    console.log(data + '---')\n  })\n} catch (error) {\n  console.log(error)\n}\n```\n\n## 加载http模块\n```js\nconst http = require('http')\n```\n\n## 创建http服务\n```js\nconst server = http.createServer()\n```\n\n## 监听'requers'事件\nserver.on()\n参数1：'requers'\n参数2：回调函数，必填\n    - req: 请求对象 包含了请求报文解析后的数据 通过它可以获取前端提交的数据\n    - res: 响应对象 通过它给前端发送响应或者设置响应头等操作 ...\n```js\nserver.on('request', function (req, res) {\n    // res.setHeader('Content-Type', 'text/plain;charset=utf8') //请求头\n    // res.end('发给前端的数据')\n  console.log('有人请求了~~');\n});\n```\n\n## 启动服务，开始监听\n```js\nserver.listen(9000, function () {\n  console.log('服务已经启动，请访问： http://localhost:9000');\n});\n```\n\n## path\n```js\nconst path = require('path')\n```\n## mime\n// 初始化: npm init -y \n// 安装: npm i mime\n```js\nconst mime = require('mime')\n\n  // 统一设置mimeType类型\n  // mime.getType => 根据提供的后缀生成不同的mimeType类型\n  res.setHeader('Content-Type', mime.getType(req.url))\n```\n## path.join()\n<!-- 一般用在路径书写上 -->\npath.join() 方法使用平台特定的分隔符把全部给定的 path 片段连接到一起，并规范化生成的路径。\n\n## 通过设置 http 响应报文头实现弹框下载功能\n1.设置 Content-Type: application/octet-stream || application/force-download\n2.设置 Content-Disposition: attachment; filename=demo.txt\n\n```js\nserver.on('request',(req, res) => {\n  // 处理url 截取最后一个/的文件名\n   res.setHeader(\"Content-Type\",\"text/plain;charset=utf-8\") //转义\n  let pathName = req.url.substring(req.url.lastIndexOf('/') + 1)\n  res.setHeader('Content-Type', 'application/force-download')\n  res.setHeader('Content-Disposition', `attachment; filename=${pathName}`)\n \n  fs.readFile(path.join(__dirname, 'download', pathName),(err, data) => {\n    // if (err) throw err\n    res.end(data)\n  })\n})\nserver.listen(3000, () => {\n  console.log('服务启动 ~')\n})\n```\n\n## request对象 和 response对象\n### request 对象\n 1.request 对象类型 <http.IncomingMessage>, 继承自stream.Readable\n 2.request 对象常用成员\n   - request.headers\n   - request.rawHeaders\n   - request.httpVersion\n   - request.method\n   - request.url\n### response 对象\n1.response 对象类型 <http.ServerResponse>\nresponse.writeHead\nresponse.write\nresponse.end\nresponse.setHeader\nresponse.statusCode\nresponse.statusMessage\n\n\n## 模板\n```js\nconst _ = require('underscore')\n\n// let names = ['zs','ls','ww']\n// let ages = [18,20,33]\n// let arr = _.zip(names,ages)\n\n// template\n//1. 准备模板\nlet str = '<h3><%= title %></h3>'\n//2. 准备数据\nlet title = '第9教学周期'\n//3. 将模板编译为可以用于页面呈现的函数\nlet fn = _.template(str)\n\nlet html = fn({title})\n\nconsole.log(html);\n```\n\n\n## 为什么会有 Buffer 类型？\n1. Buffer 使用来临时存储一些数据（二进制数据）\n2. 当我们要把一大块数据从一个地方传输到另外一个地方的时候可以通过 Buffer 对象进行传输\n3. 通过 Buffer 每次可以传输小部分数据，直到所有数据都传输完毕。\n\n## res.end和res.send的区别?\n  1、end支持的数据类型:Buffer对象, 字符串\n  2、send支持的数据类型:Buffer对象,字符串,对象,布尔,数组\n  1、end默认不会自动匹配一些响应头给浏览器 需要手动设置 res.setHeader(...)\n  2、send会自动匹配一些响应头给浏览器 解决乱码等问题\n\n## 加载 Express\n```js\n  const express = require('express')\n```\n## 调用 express() 得到一个app实例\n```js\n  const app = express()\n```\n\n## 路由\n\napp.get :\n   1、限制请求路径 需要完全匹配\n   2、限制请求方式 需要完全匹配\napp.use:\n   1、不限制请求方式 任何请求方式都可以 => 使用中间件\n   2、限制请求路径 需要第一段完全匹配即可(pathName)\napp.all:\n   1、不限制请求方式 任何请求方式都可以\n   2、限制请求路径 需要完全匹配\n\n```js\n  app.get('/', (req, res)=> {})\n```\n## 监听端口号，启动 Web 服务\n```js\napp.listen(3000, ()=> {\n  console.log('服务启动 ~')\n})\n```\n\n## express中requst对象新增的成员\n1. req.body: 需要使用中间件body-parsing解析提交的请求体\n2. req.params 获取params方式传递的参数 / 后面的参数\n3. req.query 获取query方式传递的参数 ? 后面的查询字符串 => { age: '18' }\n4. req.cookies 获取前端提交的cookies => 需要配合cookie-parser中间件使用\n5. req.path 请求路径 域名后面?前面的内容\n\n## express重定向\n```js\n res.redirect('/index')\n```\n## express 中 res对象新增的成员\nres.send: \nres.redirect: 重定向\nres.sendFile : 读取文件并响应\nres.set: 设置响应头\nres.type: 获取mimeType类型\n```js\nres.sendFile(path.join(__dirname, 'index.html'), (err)=> {\n    if(err) throw err \n  })\n```\n## 静态资源托管\n```js\n  app.use(express.static(path.join(__dirname, 'public')))\n```\n 默认第一个参数为 / 表示的是根路径\n 中间件是有执行顺序的 从上往下依次执行\n 如果第一个托管的目录中查找不到指定的资源 就继续往下匹配\n\n## ejs模板\n```js\nconst ejs = require('ejs')\nconst path = require('path')\n\n// 1、准备数据\nlet user = {name: 'zs'}\n\n// 2、准备模板\nlet str = '<h3><%= user.name %></h3>'\n\n// 3、生成模板\n// let fn = ejs.compile(str)\n// console.log(fn({user}))\n\n// console.log(ejs.render(str, {user}))\n\nejs.renderFile(path.join(__dirname, '04-ejs模板.ejs'), {user}, (err, data)=> {\n  if(err) throw err\n  console.log(data)\n})\n```\n## 中间件\n 我们希望在不修改原有代码的情况下 去新增一个打印日志的功能 => 中间件\n 中间件一定是一个函数\n ```js\napp.use('/', function (req, res, next) {\n  console.log(req.method, req.url, Date.now())\n  // 对req进行增强\n  // req.num = 10\n  // req.sayHi = function(){\n  //   console.log('111')\n  // }\n  // 放行 交出执行权 继续匹配下一个中间件\n  next()\n})\n ```","tags":["NodeJs"],"categories":["后端"]},{"title":"React 学习","url":"/2023/06/08/React-学习/","content":"\n\n## React 简介\n\n\n\n### 一、什么是 React ？(What is React？)\n\n  > React是一个声明式的，高效的，并且灵活的用于构建用户界面的 JavaScript 库。它允许您使用”components(组件)“（小巧而独立的代码片段）组合出各种复杂的UI。\n\n\n### 二、React谁开发的？\n\n  > 由Facebook开发且开源，近十年“陈酿”，阿里等大厂开始使用\n\n\n### 三、为什么要学？\n\n\n  #### &nbsp;(一)原生js痛点\n\n  1. 原生JavaScript操作DOM繁琐、效率低（DOM-API操作UI）\n\n    ```js\n    document.getElementById('app')\n    document.querySelector('#app')\n    document.getElementsByTagName('span')\n    ```\n\n  2. 使用JavaScript直接操作DOM，浏览器会进行大量的重绘重排\n\n  3. 原生JavaScript没有组件化（模块化）编码方案，代码复用率低\n\n\n  #### (二)React特点\n\n  1. 采用组件化模式，声明式编码，提高开发效率和组件复用率\n\n  2. 在React Native中可以用React语法进行移动端开发\n\n  3. 使用虚拟DOM和优秀的Diffing算法，尽量减少与真实DOM的交互，提高性能\n\n\n### 四、React依赖介绍？\n\n\n  >待更新~\n\n\n\n\n## React笔记\n\nindex.js 入口js: 用react-dom渲染注入点\n```js\nconst root = ReactDOM.createRoot(dom节点)\nroot.render(<App />)\n\n```\n\n## Jsx是什么？\n  JSX是React.createElement的语法糖\n\n## jsx和React.createElement的互相转换\n\n```js\nconst a = React.createElement(\"ul\", null,\n  React.createElement('li', {className: 'item'}, 1),\n  React.createElement('li', {className: 'item'}, 2),\n  React.createElement('li', {className: 'item'}, 3),\n)\n```\n\n```jsx\n<ul>\n  <li className='item'>1</li>\n  <li className='item'>2</li>\n  <li className='item'>3</li>\n</ul>\n```\n\n## children位置的内容自动转义\n\n```js\n<div dangerouslySetInnerHTML={{__html: \"<b>hello</b> world\"}}></div>\n```\n\n\n## 循环渲染\n\n**数组里的jsx元素要有key属性，key值是能代表数据的唯一的字符串，通常来说key应该是数组元素的id值，如果没有这种数据用索引作为唯一值。**\n\n数组渲染时key的意义：\n- 提高渲染效率\n- key用index的缺陷：不能有效的更新jsx组件，index不得已的时候使用\n\n## 代码碎片/代码片段组件: React.Fragment\n目的：作为数组的上级容器组件，但不渲染额外dom元素\n简写方式：`<>...</>`  <!-- 需要key值写法 <React.Fragment key={id}>...</React.Fragment> -->\n\n## 自定义组件\n命名：首字母大写的驼峰结构\n函数组件：一个函数返回jsx对象就叫做函数组件\n函数组件的属性就是函数的第一个参数，是object类型\n\n父传子：通过属性\n\n### React的事件\n React html组件上的dom定义的事件，回调函数里的event对象兼容dom的event\n- 取得触发事件的元素：event.target\n- 取得触发事件的名字：event.name\n- 取消默认动作：event.preventDefault()\n- 取消冒泡：event.stopPropagation()\n\n\n\n# 状态 State (相对于Props)\nprops是一个js的object\nstate也是一个js的object\n状态就是一种内部的属性 (不是通过父组件传给子组件的，是组件自己维护的属性)\n父组件的state 传给子组件，就是子组件的属性\n\n### 钩子函数 Hook  16.8\n提供钩子函数使函数组件有各种其他的功能。\n使用钩子函数的两个重点：\n1. 钩子函数只能使用在函数组件或者自定义的钩子函数里。\n2. 钩子函数只能在函数体的最外层生命周期里调用，不能在if/循环里调用。\n\n\n### 对数组类型state的修改\n正确处理方式：\n将修改的内容放入一个新的数组 （对象），将它设置为下一次的状态，（当前状态 === 新的状态 是 false，就会进入重新渲染）\n\n添加：\n```js\nsetState([...原数组,新增数据])\nsetState([...numbers,Math.random()])\n```\n\n删除：\n```js\nsetState(原数组.filter(过滤条件的函数))\nsetState(numbers.filter((n,i)=>i!==index))\n```\n\n修改：\n```js\nsetState([...原数组.slice(0,index),修改位置的新值,...原数组.slice(index+1)])\n\nsetState([ \n  ...state.slice(0,index),\n  {...state[index],name:10},\n  ...state.slice(index+1)\n])\n```\n\n## 类组件和函数组件的区别\n- 类组件有状态，函数组件无状态。\n- 类组件有生命周期函数，函数组件无生命周期函数。\n函数组件不是用来替换类组件的。\n\n## 对状态值为数组类型的更新\n\n增加\n```js\nstate = {numbers: []}\n// 正确做法\nthis.setState({numbers: [...this.state.numbers, 1]})\n```\n\n删除\n```js\nstate = {numbers: [9,8,7]}\nthis.setState({numbers: numbers.filter((n, index) => index !== 2)})\n```\n\n修改\n```js\nstate = {numbers: [9,8,7,4]}\nthis.setState(\n  {numbers: [...numbers.slice(0, 1), 80, ...numbers.slice(2)]}\n)\n```\n\n## useEffect 函数的定义：\n\n没有返回值\n\n参数有2个：\n\n第一个参数是一个回调函数，这个回调函数执行的内容叫做\"副作用\"，回调函数的返回值可以是空或者一个无参数的函数，无参数的函数叫做\"消除副作用\"\n\n执行副作用的过程：挂载+更新后\n消除副作用的过程：上次更新后的消除过程+卸载\n\n函数组件的生命周期：\n\n挂载：render，执行副作用\n更新：render，消除上次副作用，执行副作用\n卸载：消除上次副作用\n\n第二个参数是指副作用的依赖关系（depends），数组或者空\n\n- depends = 空，挂载和卸载一定会执行，每次render后会执行\n- depends = []，只会挂载和卸载的时候执行，更新过程里不会执行\n- depends = [props1,state1 ...],挂载和卸载一定会执行，这次渲染的时候数组当中的变量和上次渲染的时候是不一样的，如果发生变化就会执行，没有发生变化就不会执行\n\n\n\n# 类组件的生命周期\n\n  **三个大的阶段：挂载，更新，卸载**\n\n  ## 挂载阶段\n    - constructor(props)\n      - 适合做初始化state和其他变量\n      - 不适合做发起异步网络请求，查询dom，其他副作用的过程，this.setState（constructor初始化state用直接赋值就可以了，不用setState）\n    - render() 渲染\n    - componentDidMount() 组件挂载完成\n  ## 更新阶段 （0次或n次）\n\n    - shouldComponentUpdate (nextProps /* 下次属性 */, nextState/* 下次状态 */) 返回boolean值。\n        含义：要不要更新component？React.Component上的shouldComponentUpdate默认返回true\n    - componentDidUpdate(previousProps/* 上次的属性 */, previousState/* 上次的状态 */) 组件更新完成，dom元素渲染生效后 (previous上一次)\n      - 适合发起副作用；测量dom元素；允许执行this.setState，注意有条件的执行\n\n    this.forceUpdate() 强制刷新，略过shouldComponentUpdate\n\n  ## 卸载阶段\n\n    - componentWillUnmount() 组件即将被卸载，组件一生中只会执行一次\n      - 适合做清理componentDidMount里开启的副作用\n      - 不适合发起副作用，或者this.setState\n\n\n\n## Ref\n\n作用：用来获取渲染dom元素或者jsx元素，函数组件获取不到ref\n  ### 使用场景\n  - 管理焦点，媒体播放，文本选择\n  - 尺寸的测量\n  - 强制触发动画\n  - 集成第三方 dom 库\n  \n  React不能用dom获取元素，要使用ref\n\n  ## 使用 Ref\n    ### 函数组件里使用\n\n    useRef 钩子函数\n\n    ```jsx\n    import { useRef, useEffect } from 'react'\n\n    function MyComponent() {\n      const h = useRef() // {current: undefined}\n      const k = useRef()\n      useEffect(() => {\n        console.log(h)\n      }, [])\n      return <h1 ref={h}>hello</h1>\n    }\n    ```\n\n    ref 属性不是 html 组件的属性，类似于 key 属性，属于 react 系统所需要的属性\n\n    useRef() 总返回同一个对象 `{current: null}`\n\n    ### 类组件里使用\n\n    ref 对象用 React.createRef()获得\n\n    ```js\n    import React from 'react'\n\n    class MyComponent2 extends React.Component {\n      constructor(props) {\n        super(props)\n        this.input = React.createRef() // {current: undefined}\n      }\n\n      render() {\n        return (\n          <div>\n            <h1 ref={this.input}>你好</h1>\n            <button onClick={() => console.log(this.input)}>click</button>\n          </div>\n        )\n      }\n    }\n    ```\n\n    ### 回调函数方式\n\n    形式：`<组件 ref={(元素) => {v1 = 元素}}/>`\n\n    用途：\n    - 通用，函数组件和类组件都可以用\n    - 可以跟精细的处理ref属性\n\n    ```js\n    const MyComponent3 = () => {\n      let ref = null\n      return (\n        <>\n          <ul>\n            <li ref={(el)=>{ref=el}}>hello</li>\n          </ul>\n          <button onClick={() => console.log(ref)}>console.log(ref)</button>\n        </>\n      )\n    }\n    ```\n\n    ```js\n    const students = [\n      {id:1,name: 'Alice'}，\n      {id:2,name: 'Bob'},\n      {id:3,name: 'Carrey'}\n    ]\n    const MyComponent4 = () => {\n      // let ref = [useRef(), useRef(), useRef()]\n      let ref = []\n      return (\n        <>\n          <ul>\n            {students.map((s, index) => <li key={s.id} ref={el => {\n              ref[index] = el\n            }}>{s.name}</li>)}\n          </ul>\n          <button onClick={() => console.log(ref)}>console.log(ref)</button>\n        </>\n      )\n    }\n    ```\n\n## 路由\n  ### 原理\n  新浏览器：history对象管理的api   （history.pushState/replaceState）\n  window.onpopstate - history记录前后移动的时候会触发这个事件\n\n  ### 创建路由环境\n  浏览器环境里的路由器：BrowserRouter, HashRouter\n  import {BrowserRouter as Router} from 'react-router-dom'\n  **所有的路由都需要在路由环境里**\n  \n  ### 配置路由\n  \n  **路由设置组件：Route, Switch, Redirect,Link,NavLink**\n  \n  #### Route组件\n  \n  location 和 Route 规则如果匹配的上，就会渲染这个路由\n  \n  属性：\n  - 和匹配有关的属性\n    - path 路径配置：必须从根目录开始(path='/about', path='/account/passwd', 错误path='contact')\n    - exact 精确匹配，默认exact=false\n    - strict 严格匹配，默认exact=false，精确匹配的优先级比严格匹配高\n    - sensitive 大小写匹配，默认sensitive=false，大小写匹配优先级比精确匹配高，sensitive > exact > strict\n  - 和渲染有关的属性\n    - render: 回调函数（匿名自定义组件），返回jsx对象，render只在路由匹配情况下运行回调函数\n    - children\n      - 回调函数，返回jsx对象, 不论路由是否匹配，函数都运行\n      - jsx元素\n    - component: 自定义组件（不是jsx元素）\n  \n  #### Switch组件\n  作用：Switch组件的children是一组Route组件，按顺序，哪个路由组件先匹配到当前的location，哪个路由就渲染，其他的路由被忽略。\n  \n  #### Redirect组件\n  \n  用组件渲染的方式实现地址专向\n  \n  - 路由属性\n    - exact 精确匹配\n    - strict 严格匹配\n    - sensitive 大小写匹配\n  \n  #### Link组件\n  属性\n  - to\n    - 字符串： to='/', to='/blogs?limit=10#blog-1'\n    - location object，比字符串形式能够多传递state属性（历史记录的state）\n    - 函数：(location) => 返回新location对象，为了生成动态的地址\n  - replace 开关属性，replace默认值false，决定点击链接时是不是替换replace历史记录\n  - component用其他的组件渲染Link组件\n  \n  ## NavLink组件 -导航链接\n  NavLink继承Link组件的所有属性\n  \n  特殊属性：\n  - 路由上的匹配属性\n    - exact 精确匹配\n    - strict 严格匹配\n    - sensitive 大小写匹配\n  - 显示是否选中的属性\n    - className\n      - 除了字符串类型以为可以写回调函数(isActive/*有没有匹配当前路径*/)=>返回自己的class Name\n      - style\n        - (isActive)=>返回自己的style对象\n\n\n## 上下文 Context\n\n### 用途\n\nContext 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。\n\n### Context什么时候用？\n\n- 共享全局状态\n- 风格主题\n- 应用设置\n- 登录的用户信息\n- 用户设置\n- 多语言系统\n- 一系列共享的服务\n\n### 如何使用Context\n\n第一步：创建Context\n\n```js\nconst Context = React.createContext(默认值)\n```\n\n注意：默认值是在消费Context的时候，没有指定Context的上下文的时候才会有效。\n\n第二步：提供Context容器\n\nContext.Provider 组件内的子组件都属于这个上下文的环境。\n\n```js\n<Context.Provider value={value}>\n...\n</Context.Provider>\n```\n\n第三步：消费Context的Value\n\n接收Context的value\n\n包含三种方式\n\n1. 设置class的static contextType属性\n\n- 只能在类组件中使用\n- 通过this.context访问对应context的值\n- 特点：只能消费一个Context\n\n```js\nclass Child extends React.Component {\n  static contextType = MyContext\n  ...\n  method() {\n    // 操作this.context\n  }\n}\n```\n\n2. Context.Consumer 消费者标签\n\n- 在类组件和函数组件中都可以使用\n- Context.Consumer元素的children只能有一个，且是以context的值为参数的回调函数，该函数应该返回所渲染的JSX对象\n- 特点：\n  - 通用性好；\n  - 支持多个上下文同时消费的能力；\n  - 只能在render函数中使用。\n\n```js\nclass Child extends React.Component {\n  render() {\n    return(\n      <MyContext.Consumer>\n      {\n        value => {\n          return ...\n        }\n      }\n      </MyConText.Consumer>\n    }\n  }\n}\n```\n\n3. useContext(Context)\n\n- 只能在函数组件中使用\n- useContext(Context)返回该context的值\n- 特点：\n  - 支持多个上下文同时消费的能力；\n  - 使用灵活。\n\n```js\nfunction Child() {\n  const context = useContext(MyContext)\n  return ...\n}\n```\n\n\n## 渲染原理\n\n渲染并不是已经在dom上生成了html结构。渲染就是生成jsx对象（树）。\n\n- 挂载的渲染一定会发生\n- 重新渲染\n  - 以下发生改变的时候渲染（更新时的渲染）\n    - props\n    - state\n    - 消费的context\n  - 类组件执行this.forceUpdate()\n  - 父组件重新渲染的时候，所有后代节点都会重新渲染\n\n### 类组件优化\n\n通过继承React.PureComponent，可以优化组件，在自己的属性或state没有发生改变时，不会因为父组件重新渲染，而导致自身重新渲染。\n\n```js\nclass MyComponent extends React.PureComponent {\n  ...\n}\n```\n\n原理：\n\n普通的时候类组件继承自React.Component，shouldComponentUpdate函数永远都直接返回true（不做对比），每次都渲染。\n\n如果使用React.PureComponent作为父类，shouldComponentUpdate函数里会根据props/state判断和下次的props/state是否发生改变，如果有改变才返回true，否则返回false，返回false的时候不会render。\n\n### 函数组件优化\n\n通过React.memo返回组件的高阶组件，该高阶组件在外部的props没有发生变化时不会重新渲染。\n\n```js\nlet MyComponent = () => ...\nMyComponent = React.memo(MyComponent)\n\nexport {MyComponent}\n```\n\nReact.PureComponent 与 React.memo 功能对比\nReact.memo 返回值为高阶组件。它实现的效果与  React.PureComponent 相似，不同的是：\n\n- React.memo 用于函数组件\n- React.PureComponent 适用于 class 组件\n- React.PureComponent 只是浅比较 props、state，React.memo 也是浅比较，但它可以自定义比较函数\n\n### 为什么不是所有的组件都按照PureComponent的机制当成默认渲染逻辑？\n\n因为比较属性或state也有性能消耗，有些时候有些组件并不需要特别比较属性或state，因为他们本来就是每时每刻都会渲染的，因此这种时候做这种对比是没有意义的，反而增加了运算负担。\n\n## useCallback/useMemo\n\n### 为什么要缓存function或对象？\n\n- 节省服务对复杂运算的损耗；\n- 从缓存机制的考虑：当组件上的属性值是引用类型（往往是传递回调函数给属性），父组件重新渲染的时候，子组件的这个属性总是得到一个新的对象，使上面的这种对比的机制失效，每次对比完的结果都是需要重新渲染，使得上面（PureComponent或React.memo）优化没有作用，反而做了多余的运算。\n\n解决办法：让这种属性在没有发生功能的变化的时候使用相同的值\n\n### useCallback的用法\n\n- 参数：\n  1. 函数\n  2. 依赖关系数组：当依赖关系里的数据发生改变，会返回新的函数，如果依赖关系没变，得到上一次缓存的函数。\n    - 注意：useEffect使用undefined作为依赖关系，有意义；useCallback使用undefined/null作为依赖关系，没有意义。\n- 返回值：函数\n\n目的：组件属性得到的函数值，在不需要发生变化的时候，总得到同一个值，这样避免因为函数引用不同产生的多余的渲染\n\n```js\n// 平时\nconst handleClick= (item, index)=> { ... }\n// 优化\nconst handleClick = useCallback((item, index)=> { ... }, [...])\n```\n\n#### 什么情况下使用useCallback\n\n需要调用useCallback：\n当传递属性的组件是PureComponent或者React.memo()的组件，回调方法需要用useCallback生成。\n\n不需要调用useCallback：\n- 组件结构简单，重新渲染的效能不会消耗过高，不用做缓存。\n- html组件上的回调方法不用useCallback处理。\n\n### useMemo\n\n- 参数：\n  1. 回调函数: 没有参数，有返回值\n  2. 依赖关系的数组\n    - 注意：useMemo的依赖关系是null/undefined，是没有意义的，因为这样每次render的时候，都会执行回调函数。\n- 返回值\n  - 参数一：回调函数的执行结果\n\n用途：\n1. 减少重复性的复杂运算\n2. 在依赖关系不变的情况下，得到相同的对象引用（跟useCallback得到不变的函数的理由类似）\n\n```js\nconst r = useMemo(() => {\n  console.log('useMemo 回调方法')\n  return 99*99\n}, [])\n```\n\n### useMemo和useCallback的差别\n\n- useMemo返回的值：任何类型的。useCallback返回函数。\nuseCallback是useMemo的特殊情况：\n```js\nconst fn = useCallback((e) => { ... }, [])\nconst fn2 = useMemo(() => {\n  return (e) => { ... }\n}, []) // 和useCallback效果一样\n```\n- useMemo的回调函数会直接执行，useCallback的回调函数不会直接执行（“直接”指调用useMemo或useCallback的时候）\n- useMemo的回调函数没有参数，useCallback的回调函数可有参数\n\n## useReducer\n\n作用：使用useReducer 替换 useState管理组件的状态。\n\n### reducer的概念来源\n\nreducer 名字（概念）是来源于 Array.prototype.reduce函数。\n\n```js\nArray.prototype.reduce((上一次运算的值, item, index, arraySelf) => {\n  ... 用上一次的值和item等数据运算\n  return 下一次的值\n}, 初始值)\n\nArray.prototype.reduce(reducer, 初始值)\n\n[5,6,7].reduce((sum, n) => {\n  return sum + n\n}, 0) // 18\n```\n\n### 什么是reducer\n\nreducer是这样一类函数：\n\n- 输入参数state和action，返回一个新的state\n- reducer是纯函数\n\n```js\nconst reducer = (state, action) => {\n  ...根据state和action计算出下一次的state\n  return 下一次的state\n}\n```\n\n### 纯函数\n\n- 不能运行副作用，比如网络请求、数据库查询\n- 纯函数返回值应该完全依赖于它接收的参数，用相同的参数调用纯函数，每次得到的结果必定相同\n- 纯函数的返回值不能有比如Math.random()或者Date.now()之类非纯函数参与\n- 不要试图修改纯函数的参数，不要改变全局环境里的变量\n\n### 使用\n\n```jsx\nconst reducer = (state, action) => {\n  switch(action.type) {\n    case ...:\n      return 新的state\n    default:\n      return state\n  }\n}\nconst initState = ...\nconst MyComponent = () => {\n  const [state, dispatch/*分发*/] = useReducer(\n    reducer, initialState/*初始状态*/)\n  return <><button\n    onClick={() => dispatch(action)}>...{state...}</button>\n}\n\n```\n完整的函数形式\n```js\nuseReducer(reducer, initState, [initiator])\n\nfunction initCount(count) { // 惰性初始化\n  return {count}\n}\n\nconst [state/*当前状态，渲染的状态*/, dispatch/* 函数，发起动作 */]\n  = useReducer(reducer, 1, initCount) // 初始值 {count: 1}\n```\n\n### 区分什么情况下用useState 和 useReducer\n\n- useState：会影响state发生改变的条件是单一的。\n- useReducer：\n  - 对一种数据操作有很多种不同的动作；\n  - 一个动作对多种数据都有影响；\n  - 状态结构比较复杂的时候用。\n\n## Redux\n\n## 什么是Redux？\n\n1. 状态（State）的容器\n2. 状态是可以预测的。\n\n## 什么是状态管理\n\n- 状态存储\n- 状态读取\n- 状态变更\n\n## 什么是数据的不可变性 Immutability  （Immu tability ）\n\nImmutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。\n\n对象修改\n```js\nconst todo = {id:1, text:'打球', completed: false}\ntodo.completed = !todo.completed // 不符合 im\nconst newTodo = {...todo, completed: !todo.completed} // 符合\n```\n\n对象删除属性\n```js\nconst person = {name:'张三', age: 19}\nconst newPerson = {...person}\ndelete newPerson.age\n```\n\n数组添加数据\n```js\nconst a = [1,2,3]\na.push(4) // 不符合im\nconst b = [...a, 4]\n```\n\n数组删除数据\n```js\nconst a = [1,2,3]\na.splice(1, 1) // 不符合im\nconst b = a.filter(n => n!=2)\n```\n\n数组修改数据\n```js\nconst a = [1,2,3]\na[1] = 4 // 不符合im\nconst b = [...a.slice(0, 1), 4, ...a.slice(2)]\n```\n\n### Redux三个原则（原理）\n\n1. 单一数据源（store）：整个应用的state被存储在一棵object 树中，并且这个object树只存在于唯一一个store中。\n2. store上的state是只读：不能直接修改state，唯一修改state的方法是发送action给store（action是一个用于描述发生事件的普通对象）。\n3. 用纯函数来执行state的修改：为了实现action改变state，要编写reducer。\n\n### 单向数据流（one-way data flow）\n\n- 用state描述应用程序在特定时间点的状态\n- 用state来渲染视图（View）\n- 当发生事件（比如用户点击按钮），state会根据发生action进行更新，生成新的state\n- 然后通知相关view重新渲染\n\n![](https://tva1.sinaimg.cn/large/e6c9d24ely1gzpo5kmd9dj20zk0o2q3i.jpg)\n\n### state\n\n- state是javascript的对象（object树）（数字，字符串，布尔值等等都可以成为state）\n- 不能被序列化的数据不要存在state上（function）\n\n### action\n\n![](https://tva1.sinaimg.cn/large/e6c9d24egy1gzql8rscaqj21680u0jt8.jpg)\n\n- action是把数据从view传给store的有效荷载（payload)\n- action是store上数据的唯一来源（dispatch(action))\n- action是javascript对象，必须有type属性表示它执行的动作，除了此之外action其他属性由开发者自己决定（通常数据放在payload里）\n\naction创建函数（action creator）：返回action对象的函数\n\n```js\nconst addTodo = (text) => ({\n  type: 'addTodo',\n  payload: {id: getNextId(), text, completed: false}\n})\n```\n\naction 的作用只是描述发生事件的事实，它不包含描述如何更新state。\n\n### reducer\n\n- reducer的概念来自于Array.prototype.reduce函数\n- reducer是纯函数\n- reducer处理action，和现有state一起，运算出新的state\n- reducer处理多种action，对于它不能处理的action，直接返回state。\n- reducer的形式 `(state=初始值, action) => newState`，注意要提供state初始值\n\n组合reducer（reducer可以互相调用）\n\n数组里父级reducer调用子级reducer\n```js\nfunction counters(state=[], action) {\n  switch(action.type) {\n    case 'addCounter':\n      return ...\n    case 'incr':\n      const counterState = state[action.payload.index]\n      const newCounterState = counter(counterState, action)\n      ...\n  }\n}\n```\n\n合并多个reducer（可以在任何地方合并多次，不要认为只能在顶级reducer合并一次）\n```js\nimport {combineReducers} from 'redux'\n\nconst reducer1 =\n  (state = {count: 0, loading: false}, action) => {...}\nconst reducer2 =\n  (state = [], action) => {...}\n\nconst reducer = combineReducers({\n  key1: reducer1,\n  key2: reducer2\n})\n// state = {key1: {count: ..., loading: ...}, key2: [...]}\n```\n\n### selector函数\n\n和useSelector的参数有关\n\n- selector是纯函数\n- selector负责将store的state数据转换成渲染需要的数据结构\n- selector函数的形式 (state) => 值\n\n```js\nconst getVisibleTodos = state => {\n  // state = {todos: [], filter: '未完成'}\n  switch(state.filter) {\n    case '未完成':\n      return state.todos.filter(todo => !todo.completed)\n    case '已完成':\n      return state.todos.filter(todo => todo.completed)\n    case '全部':\n    default:\n      return state.todos\n  }\n}\nconst todos = useSelector(getVisibleTodos)\n\nconst getCounter = (state, index) => {}\nconst counter = useSelector((state/* store上顶级的state */) => getCounter(state, index))\n```\n\n### createStore方法\n\n```js\nimport {createStore} from 'redux'\n\nconst store = createStore(\n  reducer, [初始状态 initState], [增强器 enhancer]\n)\n// 如果第二个参数是函数，它就把它当成增强器\n// 否则当成初始状态使用\nconst store = createStore(\n  reducer, applyMiddleware(...)\n)\n```\n\n### 中间件 middleware\n\n中间件：给dispatch增加额外功能，比如输出log，处理异步请求\n\n```js\nimport {createStore, applyMiddleware} from 'redux'\nconst store = createStore(\n  reducer,\n  applyMiddleware(中间件1, 中间件2, ...) // 有可能顺序的配置会影响使用\n)\n```\n\n### redux-thunk\n\nthunk：函数实现“传名调用”，用函数返回另外一个函数，固定一部分参数，返回临时函数就叫作thunk函数。\n\nredux-thunk 库让dispatch（本来dispatch只能发送action，也就是普通的object）可以发送函数作为参数 (dispatch, getState) => {}\n\nthunk action creator的形式：\n\n```js\nconst thunkAction = (...参数) => (dispatch, getState) => {\n  ...\n}\n```\n\n![](https://s2.loli.net/2022/02/24/zgStixAacEZQNJj.gif)\n![](https://s2.loli.net/2022/02/25/cITYzW9Ze4dgnCi.gif)\n\n## RTK\n\n### 创建项目\n\n```\nnpx create-react-app 项目名字 --template redux\n```\n\n如果已有的react项目\n\n```js\nnpm i @reduxjs/toolkit react-redux\n```\n\n## slice 切片\n\n利用createSlice，集中创建了跟一种应用相关数据的reducer, selectors和actions。\n\n## features 功能\n\nRTK中推荐把和应用有关的数据、组件都放在一个文件结构下，这些模块共同形成的应用功能称为feature。\n\n## configureStore\n\n替代createStore函数，使用比以前简单，自动集成了thunk中间件和开发工具。\n\n```js\nimport {configureStore} from '@reduxjs/toolkit'\n\nconst store = configureStore({\n  reducer: { // 省略自己调用combineReducer\n    key1: reducer1,\n    key2: reducer2,\n    ...\n  }\n})\n```\n\nconfigureStore自定义middleware的方式：\n\n```js\nconst store = configureStore({\n  reducer: rootReducer,\n  middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(logger),\n})\n```\n\n## createSlice\n\n通过slice对象创建reducer和actions，并且可以处理外部的actions。\n\n示例\n```js\nconst slice = createSlice({\n  name: 'todos', // 用来作为自动生成action的type前缀\n  initialState: [], // 初始状态\n  reducers: {\n    addTodo(state, {payload}) {\n      // 因为有immer支持，所以可以直接用修改内容的方式修改state\n      // 如果用immer方式，不需要写return\n      // 如果state不是引用类型（是string/number/boolean），需要return\n      state.push({...payload, completed: false})\n      // 仍然可以用immutability的方式返回数据\n      // return [...state, newTodo]\n    },\n    ... // 这种function对照经典写法的case 'todos/addTodo'\n  }\n})\n\nexport const {reducer: todosReducer} = slice // 导出reducer\nexport const {addTodo, ...} = slice.actions // 导出action\n```\n\n### createAsyncThunk\n\n生成一个异步的action，会自动发送pending/fulfilled/rejected的action\n\n```js\nexport const myThunkAction = createAsyncThunk(\n  'myThunk', // action前缀\n  // 生成其他三个action：myThunk/pending, myThunk/fulfilled, myThunk/rejected\n  async () => {\n    const data = await fetchAbc(...)\n    const result = ...\n    return result\n  }\n)\n\nconst slice = createSlice({\n  ...,\n  extraReducers: {\n    [myThunk.pending](state, action) {\n      // ....\n    },\n    [myThunk.fulfilled](state, action) {\n      // ....\n    },\n    [myThunk.rejected](state, action) {\n      // ....\n    }\n  }\n})\n```\n\n### RTK对Redux使用的优化\n\n- 用configureStore替代createStore方法，使创建store的过程更加简单，自动集成了必要的中间件（thunk和devtools）\n- 创建slice时必须给配置默认状态，避免了手工创建reducer的时候忘记给state默认值的情况。\n- 使用slice创建reducer的同时创建相关的action，减少手动创建action creator的模版代码，使用reducers对象替代switch语句。\n- 使用immer库，使reducer里可以用非immutable的风格书写纯函数，使得修改数据的书写效率和程序结构都得到大幅度的改善。\n- 使用createAsyncThunk函数创建异步方法，减少手动创建thunk action的复杂度。\n","tags":["React"],"categories":["前端"]},{"title":"Hello World","url":"/2023/05/24/hello-world/","content":"\n## “永远不要失去浪漫的能力”。\n\n  ​这个浪漫不单单是指恋爱，更多的是：\n\n  对于世界的好奇和探索，阅读和书写，天真的想法和骨子里的善良，\n\n  对于生活必要的仪式感，以及拥有对恶意和黑暗的事物抱有愤怒和反抗的能力 ~\n\n  和这个世界交手多年，渐渐失去了一些耐心，身体劳累，精神也麻木，对什么都提不起兴趣，\n\n  把漫长的生命活成同一天，但这样不行，早晚有一天是要发疯的 ~\n\n  还是要一些坚守和浪漫，要一些别人看来非必要的事物来拯救自己 ~\n\n  要一些海风，夏天的雨，要低吟的音乐和沉浸的电影，要在心里点燃一盏烛火 ~\n\n  停止被这个世界融化，花一些时间在这些事物上，\n\n  凝成自己坚固的核，保护好自己闪闪发光的部分，哪怕只是徒劳 ~\n\n  觉得难过的时候，记得抬头看看月亮 ~"}]